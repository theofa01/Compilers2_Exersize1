//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.13.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:/Users/thodo/Source/Repos/Compilers2025_2026(17)/CParser/CGrammarParser.g by ANTLR 4.13.1

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419


	using CParser;

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.13.1")]
[System.CLSCompliant(false)]
public partial class CGrammarParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		TYPE_NAME=1, AUTO=2, BREAK=3, CASE=4, CHAR=5, CONST=6, CONTINUE=7, DEFAULT=8, 
		DO=9, DOUBLE=10, ELSE=11, ENUM=12, EXTERN=13, FLOAT=14, FOR=15, GOTO=16, 
		IF=17, INT=18, LONG=19, REGISTER=20, RETURN=21, SHORT=22, SIGNED=23, SIZEOF=24, 
		STATIC=25, STRUCT=26, SWITCH=27, TYPEDEF=28, UNION=29, UNSIGNED=30, VOID=31, 
		VOLATILE=32, WHILE=33, ELLIPSIS=34, RIGHT_ASSIGN=35, LEFT_ASSIGN=36, ADD_ASSIGN=37, 
		SUB_ASSIGN=38, MUL_ASSIGN=39, DIV_ASSIGN=40, MOD_ASSIGN=41, AND_ASSIGN=42, 
		XOR_ASSIGN=43, OR_ASSIGN=44, RIGHT_OP=45, LEFT_OP=46, INC_OP=47, DEC_OP=48, 
		PTR_OP=49, AND_OP=50, OR_OP=51, LE_OP=52, GE_OP=53, EQ_OP=54, NE_OP=55, 
		SEMICOLON=56, LBRACE=57, RBRACE=58, COMMA=59, COLON=60, ASSIGN=61, LPAREN=62, 
		RPAREN=63, LBRACKET=64, RBRACKET=65, MEMBEROP=66, AMBERSAND=67, NOT=68, 
		TILDE=69, HYPHEN=70, PLUS=71, ASTERISK=72, SLASH=73, PERCENT=74, LESS=75, 
		GREATER=76, CARET=77, OR=78, QMARK=79, IDENTIFIER=80, CONSTANT=81, STRING_LITERAL=82, 
		LINECOMMENT=83, MULTIPLELINECOMMENT=84, WHITESPACE=85;
	public const int
		RULE_primary_expression = 0, RULE_postfix_expression = 1, RULE_argument_expression_list = 2, 
		RULE_unary_expression = 3, RULE_unary_operator = 4, RULE_cast_expression = 5, 
		RULE_multiplicative_expression = 6, RULE_additive_expression = 7, RULE_shift_expression = 8, 
		RULE_relational_expression = 9, RULE_equality_expression = 10, RULE_and_expression = 11, 
		RULE_exclusive_or_expression = 12, RULE_inclusive_or_expression = 13, 
		RULE_logical_and_expression = 14, RULE_logical_or_expression = 15, RULE_conditional_expression = 16, 
		RULE_assignment_expression = 17, RULE_assignment_operator = 18, RULE_expression = 19, 
		RULE_constant_expression = 20, RULE_translation_unit = 21, RULE_external_declaration = 22, 
		RULE_declaration = 23, RULE_init_declarator_list = 24, RULE_init_declarator = 25, 
		RULE_initializer = 26, RULE_initializer_list = 27, RULE_declarator = 28, 
		RULE_direct_declarator = 29, RULE_type_name = 30, RULE_pointer = 31, RULE_type_qualifier_list = 32, 
		RULE_abstract_declarator = 33, RULE_direct_abstract_declarator = 34, RULE_function_definition = 35, 
		RULE_declaration_specifiers = 36, RULE_storage_class_specifier = 37, RULE_type_specifier = 38, 
		RULE_struct_or_union_specifier = 39, RULE_struct_or_union = 40, RULE_struct_declaration = 41, 
		RULE_specifier_qualifier_list = 42, RULE_struct_declarator_list = 43, 
		RULE_struct_declarator = 44, RULE_enum_specifier = 45, RULE_enumerator_list = 46, 
		RULE_enumerator = 47, RULE_type_qualifier = 48, RULE_parameter_type_list = 49, 
		RULE_parameter_declaration = 50, RULE_compound_statement = 51, RULE_statement = 52, 
		RULE_labeled_statement = 53, RULE_expression_statement = 54, RULE_selection_statement = 55, 
		RULE_iteration_statement = 56, RULE_jump_statement = 57;
	public static readonly string[] ruleNames = {
		"primary_expression", "postfix_expression", "argument_expression_list", 
		"unary_expression", "unary_operator", "cast_expression", "multiplicative_expression", 
		"additive_expression", "shift_expression", "relational_expression", "equality_expression", 
		"and_expression", "exclusive_or_expression", "inclusive_or_expression", 
		"logical_and_expression", "logical_or_expression", "conditional_expression", 
		"assignment_expression", "assignment_operator", "expression", "constant_expression", 
		"translation_unit", "external_declaration", "declaration", "init_declarator_list", 
		"init_declarator", "initializer", "initializer_list", "declarator", "direct_declarator", 
		"type_name", "pointer", "type_qualifier_list", "abstract_declarator", 
		"direct_abstract_declarator", "function_definition", "declaration_specifiers", 
		"storage_class_specifier", "type_specifier", "struct_or_union_specifier", 
		"struct_or_union", "struct_declaration", "specifier_qualifier_list", "struct_declarator_list", 
		"struct_declarator", "enum_specifier", "enumerator_list", "enumerator", 
		"type_qualifier", "parameter_type_list", "parameter_declaration", "compound_statement", 
		"statement", "labeled_statement", "expression_statement", "selection_statement", 
		"iteration_statement", "jump_statement"
	};

	private static readonly string[] _LiteralNames = {
		null, null, "'auto'", "'break'", "'case'", "'char'", "'const'", "'continue'", 
		"'default'", "'do'", "'double'", "'else'", "'enum'", "'extern'", "'float'", 
		"'for'", "'goto'", "'if'", "'int'", "'long'", "'register'", "'return'", 
		"'short'", "'signed'", "'sizeof'", "'static'", "'struct'", "'switch'", 
		"'typedef'", "'union'", "'unsigned'", "'void'", "'volatile'", "'while'", 
		"'...'", "'>>='", "'<<='", "'+='", "'-='", "'*='", "'/='", "'%='", "'&='", 
		"'^='", "'|='", "'>>'", "'<<'", "'++'", "'--'", "'->'", "'&&'", "'||'", 
		"'<='", "'>='", "'=='", "'!='", "';'", null, null, "','", "':'", "'='", 
		"'('", "')'", null, null, "'.'", "'&'", "'!'", "'~'", "'-'", "'+'", "'*'", 
		"'/'", "'%'", "'<'", "'>'", "'^'", "'|'", "'?'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "TYPE_NAME", "AUTO", "BREAK", "CASE", "CHAR", "CONST", "CONTINUE", 
		"DEFAULT", "DO", "DOUBLE", "ELSE", "ENUM", "EXTERN", "FLOAT", "FOR", "GOTO", 
		"IF", "INT", "LONG", "REGISTER", "RETURN", "SHORT", "SIGNED", "SIZEOF", 
		"STATIC", "STRUCT", "SWITCH", "TYPEDEF", "UNION", "UNSIGNED", "VOID", 
		"VOLATILE", "WHILE", "ELLIPSIS", "RIGHT_ASSIGN", "LEFT_ASSIGN", "ADD_ASSIGN", 
		"SUB_ASSIGN", "MUL_ASSIGN", "DIV_ASSIGN", "MOD_ASSIGN", "AND_ASSIGN", 
		"XOR_ASSIGN", "OR_ASSIGN", "RIGHT_OP", "LEFT_OP", "INC_OP", "DEC_OP", 
		"PTR_OP", "AND_OP", "OR_OP", "LE_OP", "GE_OP", "EQ_OP", "NE_OP", "SEMICOLON", 
		"LBRACE", "RBRACE", "COMMA", "COLON", "ASSIGN", "LPAREN", "RPAREN", "LBRACKET", 
		"RBRACKET", "MEMBEROP", "AMBERSAND", "NOT", "TILDE", "HYPHEN", "PLUS", 
		"ASTERISK", "SLASH", "PERCENT", "LESS", "GREATER", "CARET", "OR", "QMARK", 
		"IDENTIFIER", "CONSTANT", "STRING_LITERAL", "LINECOMMENT", "MULTIPLELINECOMMENT", 
		"WHITESPACE"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "CGrammarParser.g"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static CGrammarParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}


		bool enterFunctionDeclarator = false;
		uint declaratorsNestingLevel = 0;
		string functioname = string.Empty;

		public CGrammarParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public CGrammarParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class Primary_expressionContext : ParserRuleContext {
		public Primary_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_primary_expression; } }
	 
		public Primary_expressionContext() { }
		public virtual void CopyFrom(Primary_expressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Primary_expression_StringLiteralContext : Primary_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STRING_LITERAL() { return GetToken(CGrammarParser.STRING_LITERAL, 0); }
		public Primary_expression_StringLiteralContext(Primary_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterPrimary_expression_StringLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitPrimary_expression_StringLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrimary_expression_StringLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Primary_expression_IdentifierContext : Primary_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(CGrammarParser.IDENTIFIER, 0); }
		public Primary_expression_IdentifierContext(Primary_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterPrimary_expression_Identifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitPrimary_expression_Identifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrimary_expression_Identifier(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Primary_expression_ConstantContext : Primary_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONSTANT() { return GetToken(CGrammarParser.CONSTANT, 0); }
		public Primary_expression_ConstantContext(Primary_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterPrimary_expression_Constant(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitPrimary_expression_Constant(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrimary_expression_Constant(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Primary_expression_ParenthesizedExpressionContext : Primary_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CGrammarParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CGrammarParser.RPAREN, 0); }
		public Primary_expression_ParenthesizedExpressionContext(Primary_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterPrimary_expression_ParenthesizedExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitPrimary_expression_ParenthesizedExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrimary_expression_ParenthesizedExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Primary_expressionContext primary_expression() {
		Primary_expressionContext _localctx = new Primary_expressionContext(Context, State);
		EnterRule(_localctx, 0, RULE_primary_expression);
		try {
			State = 123;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case IDENTIFIER:
				_localctx = new Primary_expression_IdentifierContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 116;
				Match(IDENTIFIER);
				}
				break;
			case CONSTANT:
				_localctx = new Primary_expression_ConstantContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 117;
				Match(CONSTANT);
				}
				break;
			case STRING_LITERAL:
				_localctx = new Primary_expression_StringLiteralContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 118;
				Match(STRING_LITERAL);
				}
				break;
			case LPAREN:
				_localctx = new Primary_expression_ParenthesizedExpressionContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 119;
				Match(LPAREN);
				State = 120;
				expression(0);
				State = 121;
				Match(RPAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Postfix_expressionContext : ParserRuleContext {
		public Postfix_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_postfix_expression; } }
	 
		public Postfix_expressionContext() { }
		public virtual void CopyFrom(Postfix_expressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Postfix_expression_ArraySubscriptContext : Postfix_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Postfix_expressionContext postfix_expression() {
			return GetRuleContext<Postfix_expressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACKET() { return GetToken(CGrammarParser.LBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACKET() { return GetToken(CGrammarParser.RBRACKET, 0); }
		public Postfix_expression_ArraySubscriptContext(Postfix_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterPostfix_expression_ArraySubscript(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitPostfix_expression_ArraySubscript(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPostfix_expression_ArraySubscript(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Postfix_expression_DecrementContext : Postfix_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Postfix_expressionContext postfix_expression() {
			return GetRuleContext<Postfix_expressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEC_OP() { return GetToken(CGrammarParser.DEC_OP, 0); }
		public Postfix_expression_DecrementContext(Postfix_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterPostfix_expression_Decrement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitPostfix_expression_Decrement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPostfix_expression_Decrement(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Postfix_expression_IncrementContext : Postfix_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Postfix_expressionContext postfix_expression() {
			return GetRuleContext<Postfix_expressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INC_OP() { return GetToken(CGrammarParser.INC_OP, 0); }
		public Postfix_expression_IncrementContext(Postfix_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterPostfix_expression_Increment(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitPostfix_expression_Increment(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPostfix_expression_Increment(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Postfix_expression_FunctionCallNoArgsContext : Postfix_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Postfix_expressionContext postfix_expression() {
			return GetRuleContext<Postfix_expressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CGrammarParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CGrammarParser.RPAREN, 0); }
		public Postfix_expression_FunctionCallNoArgsContext(Postfix_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterPostfix_expression_FunctionCallNoArgs(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitPostfix_expression_FunctionCallNoArgs(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPostfix_expression_FunctionCallNoArgs(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Postfix_expression_PrimaryExpressionContext : Postfix_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Primary_expressionContext primary_expression() {
			return GetRuleContext<Primary_expressionContext>(0);
		}
		public Postfix_expression_PrimaryExpressionContext(Postfix_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterPostfix_expression_PrimaryExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitPostfix_expression_PrimaryExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPostfix_expression_PrimaryExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Postfix_expression_FunctionCallWithArgsContext : Postfix_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Postfix_expressionContext postfix_expression() {
			return GetRuleContext<Postfix_expressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CGrammarParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Argument_expression_listContext argument_expression_list() {
			return GetRuleContext<Argument_expression_listContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CGrammarParser.RPAREN, 0); }
		public Postfix_expression_FunctionCallWithArgsContext(Postfix_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterPostfix_expression_FunctionCallWithArgs(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitPostfix_expression_FunctionCallWithArgs(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPostfix_expression_FunctionCallWithArgs(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Postfix_expression_PointerMemberAccessContext : Postfix_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Postfix_expressionContext postfix_expression() {
			return GetRuleContext<Postfix_expressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PTR_OP() { return GetToken(CGrammarParser.PTR_OP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(CGrammarParser.IDENTIFIER, 0); }
		public Postfix_expression_PointerMemberAccessContext(Postfix_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterPostfix_expression_PointerMemberAccess(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitPostfix_expression_PointerMemberAccess(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPostfix_expression_PointerMemberAccess(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Postfix_expression_MemberAccessContext : Postfix_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Postfix_expressionContext postfix_expression() {
			return GetRuleContext<Postfix_expressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MEMBEROP() { return GetToken(CGrammarParser.MEMBEROP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(CGrammarParser.IDENTIFIER, 0); }
		public Postfix_expression_MemberAccessContext(Postfix_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterPostfix_expression_MemberAccess(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitPostfix_expression_MemberAccess(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPostfix_expression_MemberAccess(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Postfix_expressionContext postfix_expression() {
		return postfix_expression(0);
	}

	private Postfix_expressionContext postfix_expression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		Postfix_expressionContext _localctx = new Postfix_expressionContext(Context, _parentState);
		Postfix_expressionContext _prevctx = _localctx;
		int _startState = 2;
		EnterRecursionRule(_localctx, 2, RULE_postfix_expression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			_localctx = new Postfix_expression_PrimaryExpressionContext(_localctx);
			Context = _localctx;
			_prevctx = _localctx;

			State = 126;
			primary_expression();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 153;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,2,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 151;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
					case 1:
						{
						_localctx = new Postfix_expression_ArraySubscriptContext(new Postfix_expressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_postfix_expression);
						State = 128;
						if (!(Precpred(Context, 7))) throw new FailedPredicateException(this, "Precpred(Context, 7)");
						State = 129;
						Match(LBRACKET);
						State = 130;
						expression(0);
						State = 131;
						Match(RBRACKET);
						}
						break;
					case 2:
						{
						_localctx = new Postfix_expression_FunctionCallNoArgsContext(new Postfix_expressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_postfix_expression);
						State = 133;
						if (!(Precpred(Context, 6))) throw new FailedPredicateException(this, "Precpred(Context, 6)");
						State = 134;
						Match(LPAREN);
						State = 135;
						Match(RPAREN);
						}
						break;
					case 3:
						{
						_localctx = new Postfix_expression_FunctionCallWithArgsContext(new Postfix_expressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_postfix_expression);
						State = 136;
						if (!(Precpred(Context, 5))) throw new FailedPredicateException(this, "Precpred(Context, 5)");
						State = 137;
						Match(LPAREN);
						State = 138;
						argument_expression_list();
						State = 139;
						Match(RPAREN);
						}
						break;
					case 4:
						{
						_localctx = new Postfix_expression_MemberAccessContext(new Postfix_expressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_postfix_expression);
						State = 141;
						if (!(Precpred(Context, 4))) throw new FailedPredicateException(this, "Precpred(Context, 4)");
						State = 142;
						Match(MEMBEROP);
						State = 143;
						Match(IDENTIFIER);
						}
						break;
					case 5:
						{
						_localctx = new Postfix_expression_PointerMemberAccessContext(new Postfix_expressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_postfix_expression);
						State = 144;
						if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
						State = 145;
						Match(PTR_OP);
						State = 146;
						Match(IDENTIFIER);
						}
						break;
					case 6:
						{
						_localctx = new Postfix_expression_IncrementContext(new Postfix_expressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_postfix_expression);
						State = 147;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 148;
						Match(INC_OP);
						}
						break;
					case 7:
						{
						_localctx = new Postfix_expression_DecrementContext(new Postfix_expressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_postfix_expression);
						State = 149;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 150;
						Match(DEC_OP);
						}
						break;
					}
					} 
				}
				State = 155;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,2,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class Argument_expression_listContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Assignment_expressionContext[] assignment_expression() {
			return GetRuleContexts<Assignment_expressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public Assignment_expressionContext assignment_expression(int i) {
			return GetRuleContext<Assignment_expressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CGrammarParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CGrammarParser.COMMA, i);
		}
		public Argument_expression_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argument_expression_list; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterArgument_expression_list(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitArgument_expression_list(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArgument_expression_list(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Argument_expression_listContext argument_expression_list() {
		Argument_expression_listContext _localctx = new Argument_expression_listContext(Context, State);
		EnterRule(_localctx, 4, RULE_argument_expression_list);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 156;
			assignment_expression();
			State = 161;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 157;
				Match(COMMA);
				State = 158;
				assignment_expression();
				}
				}
				State = 163;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Unary_expressionContext : ParserRuleContext {
		public Unary_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unary_expression; } }
	 
		public Unary_expressionContext() { }
		public virtual void CopyFrom(Unary_expressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Unary_expression_IncrementContext : Unary_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INC_OP() { return GetToken(CGrammarParser.INC_OP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Unary_expressionContext unary_expression() {
			return GetRuleContext<Unary_expressionContext>(0);
		}
		public Unary_expression_IncrementContext(Unary_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterUnary_expression_Increment(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitUnary_expression_Increment(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnary_expression_Increment(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Unary_expression_SizeofExpressionContext : Unary_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SIZEOF() { return GetToken(CGrammarParser.SIZEOF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Unary_expressionContext unary_expression() {
			return GetRuleContext<Unary_expressionContext>(0);
		}
		public Unary_expression_SizeofExpressionContext(Unary_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterUnary_expression_SizeofExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitUnary_expression_SizeofExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnary_expression_SizeofExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Unary_expression_DecrementContext : Unary_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEC_OP() { return GetToken(CGrammarParser.DEC_OP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Unary_expressionContext unary_expression() {
			return GetRuleContext<Unary_expressionContext>(0);
		}
		public Unary_expression_DecrementContext(Unary_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterUnary_expression_Decrement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitUnary_expression_Decrement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnary_expression_Decrement(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Unary_expression_UnaryOperatorContext : Unary_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Unary_operatorContext unary_operator() {
			return GetRuleContext<Unary_operatorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Cast_expressionContext cast_expression() {
			return GetRuleContext<Cast_expressionContext>(0);
		}
		public Unary_expression_UnaryOperatorContext(Unary_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterUnary_expression_UnaryOperator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitUnary_expression_UnaryOperator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnary_expression_UnaryOperator(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Unary_expression_PostfixExpressionContext : Unary_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Postfix_expressionContext postfix_expression() {
			return GetRuleContext<Postfix_expressionContext>(0);
		}
		public Unary_expression_PostfixExpressionContext(Unary_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterUnary_expression_PostfixExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitUnary_expression_PostfixExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnary_expression_PostfixExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Unary_expression_SizeofTypeNameContext : Unary_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SIZEOF() { return GetToken(CGrammarParser.SIZEOF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CGrammarParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Type_nameContext type_name() {
			return GetRuleContext<Type_nameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CGrammarParser.RPAREN, 0); }
		public Unary_expression_SizeofTypeNameContext(Unary_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterUnary_expression_SizeofTypeName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitUnary_expression_SizeofTypeName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnary_expression_SizeofTypeName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Unary_expressionContext unary_expression() {
		Unary_expressionContext _localctx = new Unary_expressionContext(Context, State);
		EnterRule(_localctx, 6, RULE_unary_expression);
		try {
			State = 179;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
			case 1:
				_localctx = new Unary_expression_PostfixExpressionContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 164;
				postfix_expression(0);
				}
				break;
			case 2:
				_localctx = new Unary_expression_IncrementContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 165;
				Match(INC_OP);
				State = 166;
				unary_expression();
				}
				break;
			case 3:
				_localctx = new Unary_expression_DecrementContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 167;
				Match(DEC_OP);
				State = 168;
				unary_expression();
				}
				break;
			case 4:
				_localctx = new Unary_expression_UnaryOperatorContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 169;
				unary_operator();
				State = 170;
				cast_expression();
				}
				break;
			case 5:
				_localctx = new Unary_expression_SizeofExpressionContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 172;
				Match(SIZEOF);
				State = 173;
				unary_expression();
				}
				break;
			case 6:
				_localctx = new Unary_expression_SizeofTypeNameContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 174;
				Match(SIZEOF);
				State = 175;
				Match(LPAREN);
				State = 176;
				type_name();
				State = 177;
				Match(RPAREN);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Unary_operatorContext : ParserRuleContext {
		public IToken op;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AMBERSAND() { return GetToken(CGrammarParser.AMBERSAND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASTERISK() { return GetToken(CGrammarParser.ASTERISK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLUS() { return GetToken(CGrammarParser.PLUS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HYPHEN() { return GetToken(CGrammarParser.HYPHEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TILDE() { return GetToken(CGrammarParser.TILDE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(CGrammarParser.NOT, 0); }
		public Unary_operatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unary_operator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterUnary_operator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitUnary_operator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnary_operator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Unary_operatorContext unary_operator() {
		Unary_operatorContext _localctx = new Unary_operatorContext(Context, State);
		EnterRule(_localctx, 8, RULE_unary_operator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 181;
			_localctx.op = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(((((_la - 67)) & ~0x3f) == 0 && ((1L << (_la - 67)) & 63L) != 0)) ) {
				_localctx.op = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cast_expressionContext : ParserRuleContext {
		public Cast_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cast_expression; } }
	 
		public Cast_expressionContext() { }
		public virtual void CopyFrom(Cast_expressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Cast_expression_CastContext : Cast_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CGrammarParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Type_nameContext type_name() {
			return GetRuleContext<Type_nameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CGrammarParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Cast_expressionContext cast_expression() {
			return GetRuleContext<Cast_expressionContext>(0);
		}
		public Cast_expression_CastContext(Cast_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterCast_expression_Cast(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitCast_expression_Cast(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCast_expression_Cast(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Cast_expression_UnaryExpressionContext : Cast_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Unary_expressionContext unary_expression() {
			return GetRuleContext<Unary_expressionContext>(0);
		}
		public Cast_expression_UnaryExpressionContext(Cast_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterCast_expression_UnaryExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitCast_expression_UnaryExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCast_expression_UnaryExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cast_expressionContext cast_expression() {
		Cast_expressionContext _localctx = new Cast_expressionContext(Context, State);
		EnterRule(_localctx, 10, RULE_cast_expression);
		try {
			State = 189;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,5,Context) ) {
			case 1:
				_localctx = new Cast_expression_UnaryExpressionContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 183;
				unary_expression();
				}
				break;
			case 2:
				_localctx = new Cast_expression_CastContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 184;
				Match(LPAREN);
				State = 185;
				type_name();
				State = 186;
				Match(RPAREN);
				State = 187;
				cast_expression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Multiplicative_expressionContext : ParserRuleContext {
		public Multiplicative_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiplicative_expression; } }
	 
		public Multiplicative_expressionContext() { }
		public virtual void CopyFrom(Multiplicative_expressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Multiplicative_expression_DivisionContext : Multiplicative_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Multiplicative_expressionContext multiplicative_expression() {
			return GetRuleContext<Multiplicative_expressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SLASH() { return GetToken(CGrammarParser.SLASH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Cast_expressionContext cast_expression() {
			return GetRuleContext<Cast_expressionContext>(0);
		}
		public Multiplicative_expression_DivisionContext(Multiplicative_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterMultiplicative_expression_Division(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitMultiplicative_expression_Division(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiplicative_expression_Division(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Multiplicative_expression_MultiplicationContext : Multiplicative_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Multiplicative_expressionContext multiplicative_expression() {
			return GetRuleContext<Multiplicative_expressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASTERISK() { return GetToken(CGrammarParser.ASTERISK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Cast_expressionContext cast_expression() {
			return GetRuleContext<Cast_expressionContext>(0);
		}
		public Multiplicative_expression_MultiplicationContext(Multiplicative_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterMultiplicative_expression_Multiplication(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitMultiplicative_expression_Multiplication(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiplicative_expression_Multiplication(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Multiplicative_expression_ModulusContext : Multiplicative_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Multiplicative_expressionContext multiplicative_expression() {
			return GetRuleContext<Multiplicative_expressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PERCENT() { return GetToken(CGrammarParser.PERCENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Cast_expressionContext cast_expression() {
			return GetRuleContext<Cast_expressionContext>(0);
		}
		public Multiplicative_expression_ModulusContext(Multiplicative_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterMultiplicative_expression_Modulus(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitMultiplicative_expression_Modulus(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiplicative_expression_Modulus(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Multiplicative_expression_CastExpressionContext : Multiplicative_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Cast_expressionContext cast_expression() {
			return GetRuleContext<Cast_expressionContext>(0);
		}
		public Multiplicative_expression_CastExpressionContext(Multiplicative_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterMultiplicative_expression_CastExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitMultiplicative_expression_CastExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiplicative_expression_CastExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Multiplicative_expressionContext multiplicative_expression() {
		return multiplicative_expression(0);
	}

	private Multiplicative_expressionContext multiplicative_expression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		Multiplicative_expressionContext _localctx = new Multiplicative_expressionContext(Context, _parentState);
		Multiplicative_expressionContext _prevctx = _localctx;
		int _startState = 12;
		EnterRecursionRule(_localctx, 12, RULE_multiplicative_expression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			_localctx = new Multiplicative_expression_CastExpressionContext(_localctx);
			Context = _localctx;
			_prevctx = _localctx;

			State = 192;
			cast_expression();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 205;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,7,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 203;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,6,Context) ) {
					case 1:
						{
						_localctx = new Multiplicative_expression_MultiplicationContext(new Multiplicative_expressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_multiplicative_expression);
						State = 194;
						if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
						State = 195;
						Match(ASTERISK);
						State = 196;
						cast_expression();
						}
						break;
					case 2:
						{
						_localctx = new Multiplicative_expression_DivisionContext(new Multiplicative_expressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_multiplicative_expression);
						State = 197;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 198;
						Match(SLASH);
						State = 199;
						cast_expression();
						}
						break;
					case 3:
						{
						_localctx = new Multiplicative_expression_ModulusContext(new Multiplicative_expressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_multiplicative_expression);
						State = 200;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 201;
						Match(PERCENT);
						State = 202;
						cast_expression();
						}
						break;
					}
					} 
				}
				State = 207;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,7,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class Additive_expressionContext : ParserRuleContext {
		public Additive_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_additive_expression; } }
	 
		public Additive_expressionContext() { }
		public virtual void CopyFrom(Additive_expressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Additive_expression_AdditionContext : Additive_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Additive_expressionContext additive_expression() {
			return GetRuleContext<Additive_expressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLUS() { return GetToken(CGrammarParser.PLUS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Multiplicative_expressionContext multiplicative_expression() {
			return GetRuleContext<Multiplicative_expressionContext>(0);
		}
		public Additive_expression_AdditionContext(Additive_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterAdditive_expression_Addition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitAdditive_expression_Addition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAdditive_expression_Addition(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Additive_expression_MultiplicativeExpressionContext : Additive_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Multiplicative_expressionContext multiplicative_expression() {
			return GetRuleContext<Multiplicative_expressionContext>(0);
		}
		public Additive_expression_MultiplicativeExpressionContext(Additive_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterAdditive_expression_MultiplicativeExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitAdditive_expression_MultiplicativeExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAdditive_expression_MultiplicativeExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Additive_expression_SubtractionContext : Additive_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Additive_expressionContext additive_expression() {
			return GetRuleContext<Additive_expressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HYPHEN() { return GetToken(CGrammarParser.HYPHEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Multiplicative_expressionContext multiplicative_expression() {
			return GetRuleContext<Multiplicative_expressionContext>(0);
		}
		public Additive_expression_SubtractionContext(Additive_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterAdditive_expression_Subtraction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitAdditive_expression_Subtraction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAdditive_expression_Subtraction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Additive_expressionContext additive_expression() {
		return additive_expression(0);
	}

	private Additive_expressionContext additive_expression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		Additive_expressionContext _localctx = new Additive_expressionContext(Context, _parentState);
		Additive_expressionContext _prevctx = _localctx;
		int _startState = 14;
		EnterRecursionRule(_localctx, 14, RULE_additive_expression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			_localctx = new Additive_expression_MultiplicativeExpressionContext(_localctx);
			Context = _localctx;
			_prevctx = _localctx;

			State = 209;
			multiplicative_expression(0);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 219;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 217;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,8,Context) ) {
					case 1:
						{
						_localctx = new Additive_expression_AdditionContext(new Additive_expressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_additive_expression);
						State = 211;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 212;
						Match(PLUS);
						State = 213;
						multiplicative_expression(0);
						}
						break;
					case 2:
						{
						_localctx = new Additive_expression_SubtractionContext(new Additive_expressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_additive_expression);
						State = 214;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 215;
						Match(HYPHEN);
						State = 216;
						multiplicative_expression(0);
						}
						break;
					}
					} 
				}
				State = 221;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class Shift_expressionContext : ParserRuleContext {
		public Shift_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_shift_expression; } }
	 
		public Shift_expressionContext() { }
		public virtual void CopyFrom(Shift_expressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Shift_expression_LeftShiftContext : Shift_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Shift_expressionContext shift_expression() {
			return GetRuleContext<Shift_expressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LEFT_OP() { return GetToken(CGrammarParser.LEFT_OP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Additive_expressionContext additive_expression() {
			return GetRuleContext<Additive_expressionContext>(0);
		}
		public Shift_expression_LeftShiftContext(Shift_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterShift_expression_LeftShift(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitShift_expression_LeftShift(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShift_expression_LeftShift(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Shift_expression_AdditiveExpressionContext : Shift_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Additive_expressionContext additive_expression() {
			return GetRuleContext<Additive_expressionContext>(0);
		}
		public Shift_expression_AdditiveExpressionContext(Shift_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterShift_expression_AdditiveExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitShift_expression_AdditiveExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShift_expression_AdditiveExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Shift_expression_RightShiftContext : Shift_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Shift_expressionContext shift_expression() {
			return GetRuleContext<Shift_expressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RIGHT_OP() { return GetToken(CGrammarParser.RIGHT_OP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Additive_expressionContext additive_expression() {
			return GetRuleContext<Additive_expressionContext>(0);
		}
		public Shift_expression_RightShiftContext(Shift_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterShift_expression_RightShift(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitShift_expression_RightShift(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShift_expression_RightShift(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Shift_expressionContext shift_expression() {
		return shift_expression(0);
	}

	private Shift_expressionContext shift_expression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		Shift_expressionContext _localctx = new Shift_expressionContext(Context, _parentState);
		Shift_expressionContext _prevctx = _localctx;
		int _startState = 16;
		EnterRecursionRule(_localctx, 16, RULE_shift_expression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			_localctx = new Shift_expression_AdditiveExpressionContext(_localctx);
			Context = _localctx;
			_prevctx = _localctx;

			State = 223;
			additive_expression(0);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 233;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,11,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 231;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
					case 1:
						{
						_localctx = new Shift_expression_LeftShiftContext(new Shift_expressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_shift_expression);
						State = 225;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 226;
						Match(LEFT_OP);
						State = 227;
						additive_expression(0);
						}
						break;
					case 2:
						{
						_localctx = new Shift_expression_RightShiftContext(new Shift_expressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_shift_expression);
						State = 228;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 229;
						Match(RIGHT_OP);
						State = 230;
						additive_expression(0);
						}
						break;
					}
					} 
				}
				State = 235;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,11,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class Relational_expressionContext : ParserRuleContext {
		public Relational_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relational_expression; } }
	 
		public Relational_expressionContext() { }
		public virtual void CopyFrom(Relational_expressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Relational_expression_LessThanContext : Relational_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Relational_expressionContext relational_expression() {
			return GetRuleContext<Relational_expressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LESS() { return GetToken(CGrammarParser.LESS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Shift_expressionContext shift_expression() {
			return GetRuleContext<Shift_expressionContext>(0);
		}
		public Relational_expression_LessThanContext(Relational_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterRelational_expression_LessThan(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitRelational_expression_LessThan(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelational_expression_LessThan(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Relational_expression_GreaterThanContext : Relational_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Relational_expressionContext relational_expression() {
			return GetRuleContext<Relational_expressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GREATER() { return GetToken(CGrammarParser.GREATER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Shift_expressionContext shift_expression() {
			return GetRuleContext<Shift_expressionContext>(0);
		}
		public Relational_expression_GreaterThanContext(Relational_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterRelational_expression_GreaterThan(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitRelational_expression_GreaterThan(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelational_expression_GreaterThan(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Relational_expression_GreaterThanOrEqualContext : Relational_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Relational_expressionContext relational_expression() {
			return GetRuleContext<Relational_expressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GE_OP() { return GetToken(CGrammarParser.GE_OP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Shift_expressionContext shift_expression() {
			return GetRuleContext<Shift_expressionContext>(0);
		}
		public Relational_expression_GreaterThanOrEqualContext(Relational_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterRelational_expression_GreaterThanOrEqual(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitRelational_expression_GreaterThanOrEqual(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelational_expression_GreaterThanOrEqual(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Relational_expression_ShiftExpressionContext : Relational_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Shift_expressionContext shift_expression() {
			return GetRuleContext<Shift_expressionContext>(0);
		}
		public Relational_expression_ShiftExpressionContext(Relational_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterRelational_expression_ShiftExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitRelational_expression_ShiftExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelational_expression_ShiftExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Relational_expression_LessThanOrEqualContext : Relational_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Relational_expressionContext relational_expression() {
			return GetRuleContext<Relational_expressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LE_OP() { return GetToken(CGrammarParser.LE_OP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Shift_expressionContext shift_expression() {
			return GetRuleContext<Shift_expressionContext>(0);
		}
		public Relational_expression_LessThanOrEqualContext(Relational_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterRelational_expression_LessThanOrEqual(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitRelational_expression_LessThanOrEqual(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelational_expression_LessThanOrEqual(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Relational_expressionContext relational_expression() {
		return relational_expression(0);
	}

	private Relational_expressionContext relational_expression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		Relational_expressionContext _localctx = new Relational_expressionContext(Context, _parentState);
		Relational_expressionContext _prevctx = _localctx;
		int _startState = 18;
		EnterRecursionRule(_localctx, 18, RULE_relational_expression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			_localctx = new Relational_expression_ShiftExpressionContext(_localctx);
			Context = _localctx;
			_prevctx = _localctx;

			State = 237;
			shift_expression(0);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 253;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 251;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,12,Context) ) {
					case 1:
						{
						_localctx = new Relational_expression_LessThanContext(new Relational_expressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_relational_expression);
						State = 239;
						if (!(Precpred(Context, 4))) throw new FailedPredicateException(this, "Precpred(Context, 4)");
						State = 240;
						Match(LESS);
						State = 241;
						shift_expression(0);
						}
						break;
					case 2:
						{
						_localctx = new Relational_expression_GreaterThanContext(new Relational_expressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_relational_expression);
						State = 242;
						if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
						State = 243;
						Match(GREATER);
						State = 244;
						shift_expression(0);
						}
						break;
					case 3:
						{
						_localctx = new Relational_expression_LessThanOrEqualContext(new Relational_expressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_relational_expression);
						State = 245;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 246;
						Match(LE_OP);
						State = 247;
						shift_expression(0);
						}
						break;
					case 4:
						{
						_localctx = new Relational_expression_GreaterThanOrEqualContext(new Relational_expressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_relational_expression);
						State = 248;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 249;
						Match(GE_OP);
						State = 250;
						shift_expression(0);
						}
						break;
					}
					} 
				}
				State = 255;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class Equality_expressionContext : ParserRuleContext {
		public Equality_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_equality_expression; } }
	 
		public Equality_expressionContext() { }
		public virtual void CopyFrom(Equality_expressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Equality_expression_EqualContext : Equality_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Equality_expressionContext equality_expression() {
			return GetRuleContext<Equality_expressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQ_OP() { return GetToken(CGrammarParser.EQ_OP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Relational_expressionContext relational_expression() {
			return GetRuleContext<Relational_expressionContext>(0);
		}
		public Equality_expression_EqualContext(Equality_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterEquality_expression_Equal(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitEquality_expression_Equal(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEquality_expression_Equal(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Equality_expression_RelationalExpressionContext : Equality_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Relational_expressionContext relational_expression() {
			return GetRuleContext<Relational_expressionContext>(0);
		}
		public Equality_expression_RelationalExpressionContext(Equality_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterEquality_expression_RelationalExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitEquality_expression_RelationalExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEquality_expression_RelationalExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Equality_expression_NotEqualContext : Equality_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Equality_expressionContext equality_expression() {
			return GetRuleContext<Equality_expressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NE_OP() { return GetToken(CGrammarParser.NE_OP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Relational_expressionContext relational_expression() {
			return GetRuleContext<Relational_expressionContext>(0);
		}
		public Equality_expression_NotEqualContext(Equality_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterEquality_expression_NotEqual(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitEquality_expression_NotEqual(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEquality_expression_NotEqual(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Equality_expressionContext equality_expression() {
		return equality_expression(0);
	}

	private Equality_expressionContext equality_expression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		Equality_expressionContext _localctx = new Equality_expressionContext(Context, _parentState);
		Equality_expressionContext _prevctx = _localctx;
		int _startState = 20;
		EnterRecursionRule(_localctx, 20, RULE_equality_expression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			_localctx = new Equality_expression_RelationalExpressionContext(_localctx);
			Context = _localctx;
			_prevctx = _localctx;

			State = 257;
			relational_expression(0);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 267;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,15,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 265;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,14,Context) ) {
					case 1:
						{
						_localctx = new Equality_expression_EqualContext(new Equality_expressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_equality_expression);
						State = 259;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 260;
						Match(EQ_OP);
						State = 261;
						relational_expression(0);
						}
						break;
					case 2:
						{
						_localctx = new Equality_expression_NotEqualContext(new Equality_expressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_equality_expression);
						State = 262;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 263;
						Match(NE_OP);
						State = 264;
						relational_expression(0);
						}
						break;
					}
					} 
				}
				State = 269;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,15,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class And_expressionContext : ParserRuleContext {
		public And_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_and_expression; } }
	 
		public And_expressionContext() { }
		public virtual void CopyFrom(And_expressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class And_expression_BitwiseANDContext : And_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public And_expressionContext and_expression() {
			return GetRuleContext<And_expressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AMBERSAND() { return GetToken(CGrammarParser.AMBERSAND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Equality_expressionContext equality_expression() {
			return GetRuleContext<Equality_expressionContext>(0);
		}
		public And_expression_BitwiseANDContext(And_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterAnd_expression_BitwiseAND(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitAnd_expression_BitwiseAND(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAnd_expression_BitwiseAND(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class And_expression_EqualityExpressionContext : And_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Equality_expressionContext equality_expression() {
			return GetRuleContext<Equality_expressionContext>(0);
		}
		public And_expression_EqualityExpressionContext(And_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterAnd_expression_EqualityExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitAnd_expression_EqualityExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAnd_expression_EqualityExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public And_expressionContext and_expression() {
		return and_expression(0);
	}

	private And_expressionContext and_expression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		And_expressionContext _localctx = new And_expressionContext(Context, _parentState);
		And_expressionContext _prevctx = _localctx;
		int _startState = 22;
		EnterRecursionRule(_localctx, 22, RULE_and_expression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			_localctx = new And_expression_EqualityExpressionContext(_localctx);
			Context = _localctx;
			_prevctx = _localctx;

			State = 271;
			equality_expression(0);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 278;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,16,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new And_expression_BitwiseANDContext(new And_expressionContext(_parentctx, _parentState));
					PushNewRecursionContext(_localctx, _startState, RULE_and_expression);
					State = 273;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 274;
					Match(AMBERSAND);
					State = 275;
					equality_expression(0);
					}
					} 
				}
				State = 280;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,16,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class Exclusive_or_expressionContext : ParserRuleContext {
		public Exclusive_or_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exclusive_or_expression; } }
	 
		public Exclusive_or_expressionContext() { }
		public virtual void CopyFrom(Exclusive_or_expressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Exclusive_or_expression_AndExpressionContext : Exclusive_or_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public And_expressionContext and_expression() {
			return GetRuleContext<And_expressionContext>(0);
		}
		public Exclusive_or_expression_AndExpressionContext(Exclusive_or_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterExclusive_or_expression_AndExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitExclusive_or_expression_AndExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExclusive_or_expression_AndExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Exclusive_or_expression_BitwiseXORContext : Exclusive_or_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Exclusive_or_expressionContext exclusive_or_expression() {
			return GetRuleContext<Exclusive_or_expressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CARET() { return GetToken(CGrammarParser.CARET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public And_expressionContext and_expression() {
			return GetRuleContext<And_expressionContext>(0);
		}
		public Exclusive_or_expression_BitwiseXORContext(Exclusive_or_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterExclusive_or_expression_BitwiseXOR(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitExclusive_or_expression_BitwiseXOR(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExclusive_or_expression_BitwiseXOR(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Exclusive_or_expressionContext exclusive_or_expression() {
		return exclusive_or_expression(0);
	}

	private Exclusive_or_expressionContext exclusive_or_expression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		Exclusive_or_expressionContext _localctx = new Exclusive_or_expressionContext(Context, _parentState);
		Exclusive_or_expressionContext _prevctx = _localctx;
		int _startState = 24;
		EnterRecursionRule(_localctx, 24, RULE_exclusive_or_expression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			_localctx = new Exclusive_or_expression_AndExpressionContext(_localctx);
			Context = _localctx;
			_prevctx = _localctx;

			State = 282;
			and_expression(0);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 289;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,17,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new Exclusive_or_expression_BitwiseXORContext(new Exclusive_or_expressionContext(_parentctx, _parentState));
					PushNewRecursionContext(_localctx, _startState, RULE_exclusive_or_expression);
					State = 284;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 285;
					Match(CARET);
					State = 286;
					and_expression(0);
					}
					} 
				}
				State = 291;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,17,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class Inclusive_or_expressionContext : ParserRuleContext {
		public Inclusive_or_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_inclusive_or_expression; } }
	 
		public Inclusive_or_expressionContext() { }
		public virtual void CopyFrom(Inclusive_or_expressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Inclusive_or_expression_ExclusiveOrExpressionContext : Inclusive_or_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Exclusive_or_expressionContext exclusive_or_expression() {
			return GetRuleContext<Exclusive_or_expressionContext>(0);
		}
		public Inclusive_or_expression_ExclusiveOrExpressionContext(Inclusive_or_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterInclusive_or_expression_ExclusiveOrExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitInclusive_or_expression_ExclusiveOrExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInclusive_or_expression_ExclusiveOrExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Inclusive_or_expression_BitwiseORContext : Inclusive_or_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Inclusive_or_expressionContext inclusive_or_expression() {
			return GetRuleContext<Inclusive_or_expressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OR() { return GetToken(CGrammarParser.OR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Exclusive_or_expressionContext exclusive_or_expression() {
			return GetRuleContext<Exclusive_or_expressionContext>(0);
		}
		public Inclusive_or_expression_BitwiseORContext(Inclusive_or_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterInclusive_or_expression_BitwiseOR(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitInclusive_or_expression_BitwiseOR(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInclusive_or_expression_BitwiseOR(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Inclusive_or_expressionContext inclusive_or_expression() {
		return inclusive_or_expression(0);
	}

	private Inclusive_or_expressionContext inclusive_or_expression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		Inclusive_or_expressionContext _localctx = new Inclusive_or_expressionContext(Context, _parentState);
		Inclusive_or_expressionContext _prevctx = _localctx;
		int _startState = 26;
		EnterRecursionRule(_localctx, 26, RULE_inclusive_or_expression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			_localctx = new Inclusive_or_expression_ExclusiveOrExpressionContext(_localctx);
			Context = _localctx;
			_prevctx = _localctx;

			State = 293;
			exclusive_or_expression(0);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 300;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,18,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new Inclusive_or_expression_BitwiseORContext(new Inclusive_or_expressionContext(_parentctx, _parentState));
					PushNewRecursionContext(_localctx, _startState, RULE_inclusive_or_expression);
					State = 295;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 296;
					Match(OR);
					State = 297;
					exclusive_or_expression(0);
					}
					} 
				}
				State = 302;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,18,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class Logical_and_expressionContext : ParserRuleContext {
		public Logical_and_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_logical_and_expression; } }
	 
		public Logical_and_expressionContext() { }
		public virtual void CopyFrom(Logical_and_expressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Logical_and_expression_InclusiveOrExpressionContext : Logical_and_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Inclusive_or_expressionContext inclusive_or_expression() {
			return GetRuleContext<Inclusive_or_expressionContext>(0);
		}
		public Logical_and_expression_InclusiveOrExpressionContext(Logical_and_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterLogical_and_expression_InclusiveOrExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitLogical_and_expression_InclusiveOrExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogical_and_expression_InclusiveOrExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Logical_and_expression_LogicalANDContext : Logical_and_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Logical_and_expressionContext logical_and_expression() {
			return GetRuleContext<Logical_and_expressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AND_OP() { return GetToken(CGrammarParser.AND_OP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Inclusive_or_expressionContext inclusive_or_expression() {
			return GetRuleContext<Inclusive_or_expressionContext>(0);
		}
		public Logical_and_expression_LogicalANDContext(Logical_and_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterLogical_and_expression_LogicalAND(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitLogical_and_expression_LogicalAND(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogical_and_expression_LogicalAND(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Logical_and_expressionContext logical_and_expression() {
		return logical_and_expression(0);
	}

	private Logical_and_expressionContext logical_and_expression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		Logical_and_expressionContext _localctx = new Logical_and_expressionContext(Context, _parentState);
		Logical_and_expressionContext _prevctx = _localctx;
		int _startState = 28;
		EnterRecursionRule(_localctx, 28, RULE_logical_and_expression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			_localctx = new Logical_and_expression_InclusiveOrExpressionContext(_localctx);
			Context = _localctx;
			_prevctx = _localctx;

			State = 304;
			inclusive_or_expression(0);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 311;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,19,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new Logical_and_expression_LogicalANDContext(new Logical_and_expressionContext(_parentctx, _parentState));
					PushNewRecursionContext(_localctx, _startState, RULE_logical_and_expression);
					State = 306;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 307;
					Match(AND_OP);
					State = 308;
					inclusive_or_expression(0);
					}
					} 
				}
				State = 313;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,19,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class Logical_or_expressionContext : ParserRuleContext {
		public Logical_or_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_logical_or_expression; } }
	 
		public Logical_or_expressionContext() { }
		public virtual void CopyFrom(Logical_or_expressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Logical_or_expression_InclusiveOrExpressionContext : Logical_or_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Logical_and_expressionContext logical_and_expression() {
			return GetRuleContext<Logical_and_expressionContext>(0);
		}
		public Logical_or_expression_InclusiveOrExpressionContext(Logical_or_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterLogical_or_expression_InclusiveOrExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitLogical_or_expression_InclusiveOrExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogical_or_expression_InclusiveOrExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Logical_or_expression_LogicalORContext : Logical_or_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Logical_or_expressionContext logical_or_expression() {
			return GetRuleContext<Logical_or_expressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OR_OP() { return GetToken(CGrammarParser.OR_OP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Logical_and_expressionContext logical_and_expression() {
			return GetRuleContext<Logical_and_expressionContext>(0);
		}
		public Logical_or_expression_LogicalORContext(Logical_or_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterLogical_or_expression_LogicalOR(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitLogical_or_expression_LogicalOR(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogical_or_expression_LogicalOR(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Logical_or_expressionContext logical_or_expression() {
		return logical_or_expression(0);
	}

	private Logical_or_expressionContext logical_or_expression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		Logical_or_expressionContext _localctx = new Logical_or_expressionContext(Context, _parentState);
		Logical_or_expressionContext _prevctx = _localctx;
		int _startState = 30;
		EnterRecursionRule(_localctx, 30, RULE_logical_or_expression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			_localctx = new Logical_or_expression_InclusiveOrExpressionContext(_localctx);
			Context = _localctx;
			_prevctx = _localctx;

			State = 315;
			logical_and_expression(0);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 322;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,20,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new Logical_or_expression_LogicalORContext(new Logical_or_expressionContext(_parentctx, _parentState));
					PushNewRecursionContext(_localctx, _startState, RULE_logical_or_expression);
					State = 317;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 318;
					Match(OR_OP);
					State = 319;
					logical_and_expression(0);
					}
					} 
				}
				State = 324;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,20,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class Conditional_expressionContext : ParserRuleContext {
		public Conditional_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditional_expression; } }
	 
		public Conditional_expressionContext() { }
		public virtual void CopyFrom(Conditional_expressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Conditional_expression_ConditionalContext : Conditional_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Logical_or_expressionContext logical_or_expression() {
			return GetRuleContext<Logical_or_expressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QMARK() { return GetToken(CGrammarParser.QMARK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(CGrammarParser.COLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Conditional_expressionContext conditional_expression() {
			return GetRuleContext<Conditional_expressionContext>(0);
		}
		public Conditional_expression_ConditionalContext(Conditional_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterConditional_expression_Conditional(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitConditional_expression_Conditional(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConditional_expression_Conditional(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Conditional_expression_LogicalOrExpressionContext : Conditional_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Logical_or_expressionContext logical_or_expression() {
			return GetRuleContext<Logical_or_expressionContext>(0);
		}
		public Conditional_expression_LogicalOrExpressionContext(Conditional_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterConditional_expression_LogicalOrExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitConditional_expression_LogicalOrExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConditional_expression_LogicalOrExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Conditional_expressionContext conditional_expression() {
		Conditional_expressionContext _localctx = new Conditional_expressionContext(Context, State);
		EnterRule(_localctx, 32, RULE_conditional_expression);
		try {
			State = 332;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,21,Context) ) {
			case 1:
				_localctx = new Conditional_expression_LogicalOrExpressionContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 325;
				logical_or_expression(0);
				}
				break;
			case 2:
				_localctx = new Conditional_expression_ConditionalContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 326;
				logical_or_expression(0);
				State = 327;
				Match(QMARK);
				State = 328;
				expression(0);
				State = 329;
				Match(COLON);
				State = 330;
				conditional_expression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Assignment_expressionContext : ParserRuleContext {
		public Assignment_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assignment_expression; } }
	 
		public Assignment_expressionContext() { }
		public virtual void CopyFrom(Assignment_expressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Assignment_expression_ConditionalExpressionContext : Assignment_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Conditional_expressionContext conditional_expression() {
			return GetRuleContext<Conditional_expressionContext>(0);
		}
		public Assignment_expression_ConditionalExpressionContext(Assignment_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterAssignment_expression_ConditionalExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitAssignment_expression_ConditionalExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssignment_expression_ConditionalExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Assignment_expression_AssignmentContext : Assignment_expressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Unary_expressionContext unary_expression() {
			return GetRuleContext<Unary_expressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Assignment_operatorContext assignment_operator() {
			return GetRuleContext<Assignment_operatorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Assignment_expressionContext assignment_expression() {
			return GetRuleContext<Assignment_expressionContext>(0);
		}
		public Assignment_expression_AssignmentContext(Assignment_expressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterAssignment_expression_Assignment(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitAssignment_expression_Assignment(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssignment_expression_Assignment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Assignment_expressionContext assignment_expression() {
		Assignment_expressionContext _localctx = new Assignment_expressionContext(Context, State);
		EnterRule(_localctx, 34, RULE_assignment_expression);
		try {
			State = 339;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,22,Context) ) {
			case 1:
				_localctx = new Assignment_expression_ConditionalExpressionContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 334;
				conditional_expression();
				}
				break;
			case 2:
				_localctx = new Assignment_expression_AssignmentContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 335;
				unary_expression();
				State = 336;
				assignment_operator();
				State = 337;
				assignment_expression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Assignment_operatorContext : ParserRuleContext {
		public IToken op;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGN() { return GetToken(CGrammarParser.ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MUL_ASSIGN() { return GetToken(CGrammarParser.MUL_ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIV_ASSIGN() { return GetToken(CGrammarParser.DIV_ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MOD_ASSIGN() { return GetToken(CGrammarParser.MOD_ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ADD_ASSIGN() { return GetToken(CGrammarParser.ADD_ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUB_ASSIGN() { return GetToken(CGrammarParser.SUB_ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LEFT_ASSIGN() { return GetToken(CGrammarParser.LEFT_ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RIGHT_ASSIGN() { return GetToken(CGrammarParser.RIGHT_ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AND_ASSIGN() { return GetToken(CGrammarParser.AND_ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XOR_ASSIGN() { return GetToken(CGrammarParser.XOR_ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OR_ASSIGN() { return GetToken(CGrammarParser.OR_ASSIGN, 0); }
		public Assignment_operatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assignment_operator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterAssignment_operator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitAssignment_operator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssignment_operator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Assignment_operatorContext assignment_operator() {
		Assignment_operatorContext _localctx = new Assignment_operatorContext(Context, State);
		EnterRule(_localctx, 36, RULE_assignment_operator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 341;
			_localctx.op = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 2305878159226044416L) != 0)) ) {
				_localctx.op = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
	 
		public ExpressionContext() { }
		public virtual void CopyFrom(ExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Expression_AssignmentExpressionContext : ExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public Assignment_expressionContext assignment_expression() {
			return GetRuleContext<Assignment_expressionContext>(0);
		}
		public Expression_AssignmentExpressionContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterExpression_AssignmentExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitExpression_AssignmentExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression_AssignmentExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expression_CommaExpressionContext : ExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(CGrammarParser.COMMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Assignment_expressionContext assignment_expression() {
			return GetRuleContext<Assignment_expressionContext>(0);
		}
		public Expression_CommaExpressionContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterExpression_CommaExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitExpression_CommaExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression_CommaExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		return expression(0);
	}

	private ExpressionContext expression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		ExpressionContext _localctx = new ExpressionContext(Context, _parentState);
		ExpressionContext _prevctx = _localctx;
		int _startState = 38;
		EnterRecursionRule(_localctx, 38, RULE_expression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			_localctx = new Expression_AssignmentExpressionContext(_localctx);
			Context = _localctx;
			_prevctx = _localctx;

			State = 344;
			assignment_expression();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 351;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,23,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new Expression_CommaExpressionContext(new ExpressionContext(_parentctx, _parentState));
					PushNewRecursionContext(_localctx, _startState, RULE_expression);
					State = 346;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 347;
					Match(COMMA);
					State = 348;
					assignment_expression();
					}
					} 
				}
				State = 353;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,23,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class Constant_expressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Conditional_expressionContext conditional_expression() {
			return GetRuleContext<Conditional_expressionContext>(0);
		}
		public Constant_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constant_expression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterConstant_expression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitConstant_expression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstant_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Constant_expressionContext constant_expression() {
		Constant_expressionContext _localctx = new Constant_expressionContext(Context, State);
		EnterRule(_localctx, 40, RULE_constant_expression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 354;
			conditional_expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Translation_unitContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(CGrammarParser.Eof, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public External_declarationContext[] external_declaration() {
			return GetRuleContexts<External_declarationContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public External_declarationContext external_declaration(int i) {
			return GetRuleContext<External_declarationContext>(i);
		}
		public Translation_unitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_translation_unit; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterTranslation_unit(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitTranslation_unit(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTranslation_unit(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Translation_unitContext translation_unit() {
		Translation_unitContext _localctx = new Translation_unitContext(Context, State);
		EnterRule(_localctx, 42, RULE_translation_unit);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 357;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 356;
				external_declaration();
				}
				}
				State = 359;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & 8436610150L) != 0) );
			State = 361;
			Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class External_declarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Function_definitionContext function_definition() {
			return GetRuleContext<Function_definitionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationContext declaration() {
			return GetRuleContext<DeclarationContext>(0);
		}
		public External_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_external_declaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterExternal_declaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitExternal_declaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExternal_declaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public External_declarationContext external_declaration() {
		External_declarationContext _localctx = new External_declarationContext(Context, State);
		EnterRule(_localctx, 44, RULE_external_declaration);
		try {
			State = 365;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,25,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 363;
				function_definition();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 364;
				declaration();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Declaration_specifiersContext declaration_specifiers() {
			return GetRuleContext<Declaration_specifiersContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(CGrammarParser.SEMICOLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Init_declarator_listContext init_declarator_list() {
			return GetRuleContext<Init_declarator_listContext>(0);
		}
		public DeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclarationContext declaration() {
		DeclarationContext _localctx = new DeclarationContext(Context, State);
		EnterRule(_localctx, 46, RULE_declaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 367;
			declaration_specifiers();
			State = 369;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (((((_la - 62)) & ~0x3f) == 0 && ((1L << (_la - 62)) & 263169L) != 0)) {
				{
				State = 368;
				init_declarator_list();
				}
			}

			State = 371;
			Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Init_declarator_listContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Init_declaratorContext[] init_declarator() {
			return GetRuleContexts<Init_declaratorContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public Init_declaratorContext init_declarator(int i) {
			return GetRuleContext<Init_declaratorContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CGrammarParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CGrammarParser.COMMA, i);
		}
		public Init_declarator_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_init_declarator_list; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterInit_declarator_list(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitInit_declarator_list(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInit_declarator_list(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Init_declarator_listContext init_declarator_list() {
		Init_declarator_listContext _localctx = new Init_declarator_listContext(Context, State);
		EnterRule(_localctx, 48, RULE_init_declarator_list);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 373;
			init_declarator();
			State = 378;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 374;
				Match(COMMA);
				State = 375;
				init_declarator();
				}
				}
				State = 380;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Init_declaratorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeclaratorContext declarator() {
			return GetRuleContext<DeclaratorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGN() { return GetToken(CGrammarParser.ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public InitializerContext initializer() {
			return GetRuleContext<InitializerContext>(0);
		}
		public Init_declaratorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_init_declarator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterInit_declarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitInit_declarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInit_declarator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Init_declaratorContext init_declarator() {
		Init_declaratorContext _localctx = new Init_declaratorContext(Context, State);
		EnterRule(_localctx, 50, RULE_init_declarator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 381;
			declarator();
			State = 384;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ASSIGN) {
				{
				State = 382;
				Match(ASSIGN);
				State = 383;
				initializer();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InitializerContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Assignment_expressionContext assignment_expression() {
			return GetRuleContext<Assignment_expressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACE() { return GetToken(CGrammarParser.LBRACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Initializer_listContext initializer_list() {
			return GetRuleContext<Initializer_listContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACE() { return GetToken(CGrammarParser.RBRACE, 0); }
		public InitializerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_initializer; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterInitializer(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitInitializer(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInitializer(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InitializerContext initializer() {
		InitializerContext _localctx = new InitializerContext(Context, State);
		EnterRule(_localctx, 52, RULE_initializer);
		try {
			State = 391;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SIZEOF:
			case INC_OP:
			case DEC_OP:
			case LPAREN:
			case AMBERSAND:
			case NOT:
			case TILDE:
			case HYPHEN:
			case PLUS:
			case ASTERISK:
			case IDENTIFIER:
			case CONSTANT:
			case STRING_LITERAL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 386;
				assignment_expression();
				}
				break;
			case LBRACE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 387;
				Match(LBRACE);
				State = 388;
				initializer_list();
				State = 389;
				Match(RBRACE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Initializer_listContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public InitializerContext[] initializer() {
			return GetRuleContexts<InitializerContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public InitializerContext initializer(int i) {
			return GetRuleContext<InitializerContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CGrammarParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CGrammarParser.COMMA, i);
		}
		public Initializer_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_initializer_list; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterInitializer_list(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitInitializer_list(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInitializer_list(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Initializer_listContext initializer_list() {
		Initializer_listContext _localctx = new Initializer_listContext(Context, State);
		EnterRule(_localctx, 54, RULE_initializer_list);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 393;
			initializer();
			State = 398;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 394;
				Match(COMMA);
				State = 395;
				initializer();
				}
				}
				State = 400;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclaratorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PointerContext pointer() {
			return GetRuleContext<PointerContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Direct_declaratorContext direct_declarator() {
			return GetRuleContext<Direct_declaratorContext>(0);
		}
		public DeclaratorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declarator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterDeclarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitDeclarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclarator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclaratorContext declarator() {
		DeclaratorContext _localctx = new DeclaratorContext(Context, State);
		EnterRule(_localctx, 56, RULE_declarator);
		 declaratorsNestingLevel++; 
		try {
			State = 405;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ASTERISK:
				EnterOuterAlt(_localctx, 1);
				{
				State = 401;
				pointer();
				State = 402;
				direct_declarator(0);
				}
				break;
			case LPAREN:
			case IDENTIFIER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 404;
				direct_declarator(0);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			 declaratorsNestingLevel--; 
			ExitRule();
		}
		return _localctx;
	}

	public partial class Direct_declaratorContext : ParserRuleContext {
		public Direct_declaratorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_direct_declarator; } }
	 
		public Direct_declaratorContext() { }
		public virtual void CopyFrom(Direct_declaratorContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ArrayDimensionWithSIZEContext : Direct_declaratorContext {
		[System.Diagnostics.DebuggerNonUserCode] public Direct_declaratorContext direct_declarator() {
			return GetRuleContext<Direct_declaratorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACKET() { return GetToken(CGrammarParser.LBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Constant_expressionContext constant_expression() {
			return GetRuleContext<Constant_expressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACKET() { return GetToken(CGrammarParser.RBRACKET, 0); }
		public ArrayDimensionWithSIZEContext(Direct_declaratorContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterArrayDimensionWithSIZE(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitArrayDimensionWithSIZE(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArrayDimensionWithSIZE(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class FunctionWithNOArgumentsContext : Direct_declaratorContext {
		[System.Diagnostics.DebuggerNonUserCode] public Direct_declaratorContext direct_declarator() {
			return GetRuleContext<Direct_declaratorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CGrammarParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CGrammarParser.RPAREN, 0); }
		public FunctionWithNOArgumentsContext(Direct_declaratorContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterFunctionWithNOArguments(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitFunctionWithNOArguments(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionWithNOArguments(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ParenthesisContext : Direct_declaratorContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CGrammarParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DeclaratorContext declarator() {
			return GetRuleContext<DeclaratorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CGrammarParser.RPAREN, 0); }
		public ParenthesisContext(Direct_declaratorContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterParenthesis(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitParenthesis(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParenthesis(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ArrayDimensionWithNOSIZEContext : Direct_declaratorContext {
		[System.Diagnostics.DebuggerNonUserCode] public Direct_declaratorContext direct_declarator() {
			return GetRuleContext<Direct_declaratorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACKET() { return GetToken(CGrammarParser.LBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACKET() { return GetToken(CGrammarParser.RBRACKET, 0); }
		public ArrayDimensionWithNOSIZEContext(Direct_declaratorContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterArrayDimensionWithNOSIZE(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitArrayDimensionWithNOSIZE(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArrayDimensionWithNOSIZE(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class FunctionWithArgumentsContext : Direct_declaratorContext {
		[System.Diagnostics.DebuggerNonUserCode] public Direct_declaratorContext direct_declarator() {
			return GetRuleContext<Direct_declaratorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CGrammarParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Parameter_type_listContext parameter_type_list() {
			return GetRuleContext<Parameter_type_listContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CGrammarParser.RPAREN, 0); }
		public FunctionWithArgumentsContext(Direct_declaratorContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterFunctionWithArguments(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitFunctionWithArguments(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionWithArguments(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class IDENTIFIERContext : Direct_declaratorContext {
		public IToken _IDENTIFIER;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(CGrammarParser.IDENTIFIER, 0); }
		public IDENTIFIERContext(Direct_declaratorContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterIDENTIFIER(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitIDENTIFIER(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIDENTIFIER(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Direct_declaratorContext direct_declarator() {
		return direct_declarator(0);
	}

	private Direct_declaratorContext direct_declarator(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		Direct_declaratorContext _localctx = new Direct_declaratorContext(Context, _parentState);
		Direct_declaratorContext _prevctx = _localctx;
		int _startState = 58;
		EnterRecursionRule(_localctx, 58, RULE_direct_declarator, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 414;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case IDENTIFIER:
				{
				_localctx = new IDENTIFIERContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;

				State = 408;
				((IDENTIFIERContext)_localctx)._IDENTIFIER = Match(IDENTIFIER);

						if(enterFunctionDeclarator && declaratorsNestingLevel==1)
						{
							functioname = (((IDENTIFIERContext)_localctx)._IDENTIFIER!=null?((IDENTIFIERContext)_localctx)._IDENTIFIER.Text:null);
						}
					
				}
				break;
			case LPAREN:
				{
				_localctx = new ParenthesisContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 410;
				Match(LPAREN);
				State = 411;
				declarator();
				State = 412;
				Match(RPAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 434;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,34,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 432;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,33,Context) ) {
					case 1:
						{
						_localctx = new ArrayDimensionWithSIZEContext(new Direct_declaratorContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_direct_declarator);
						State = 416;
						if (!(Precpred(Context, 4))) throw new FailedPredicateException(this, "Precpred(Context, 4)");
						State = 417;
						Match(LBRACKET);
						State = 418;
						constant_expression();
						State = 419;
						Match(RBRACKET);
						}
						break;
					case 2:
						{
						_localctx = new ArrayDimensionWithNOSIZEContext(new Direct_declaratorContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_direct_declarator);
						State = 421;
						if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
						State = 422;
						Match(LBRACKET);
						State = 423;
						Match(RBRACKET);
						}
						break;
					case 3:
						{
						_localctx = new FunctionWithArgumentsContext(new Direct_declaratorContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_direct_declarator);
						State = 424;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 425;
						Match(LPAREN);
						State = 426;
						parameter_type_list();
						State = 427;
						Match(RPAREN);
						}
						break;
					case 4:
						{
						_localctx = new FunctionWithNOArgumentsContext(new Direct_declaratorContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_direct_declarator);
						State = 429;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 430;
						Match(LPAREN);
						State = 431;
						Match(RPAREN);
						}
						break;
					}
					} 
				}
				State = 436;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,34,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class Type_nameContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Specifier_qualifier_listContext specifier_qualifier_list() {
			return GetRuleContext<Specifier_qualifier_listContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Abstract_declaratorContext abstract_declarator() {
			return GetRuleContext<Abstract_declaratorContext>(0);
		}
		public Type_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_name; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterType_name(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitType_name(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Type_nameContext type_name() {
		Type_nameContext _localctx = new Type_nameContext(Context, State);
		EnterRule(_localctx, 60, RULE_type_name);
		try {
			State = 441;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,35,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 437;
				specifier_qualifier_list();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 438;
				specifier_qualifier_list();
				State = 439;
				abstract_declarator();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PointerContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASTERISK() { return GetToken(CGrammarParser.ASTERISK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Type_qualifier_listContext type_qualifier_list() {
			return GetRuleContext<Type_qualifier_listContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PointerContext pointer() {
			return GetRuleContext<PointerContext>(0);
		}
		public PointerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pointer; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterPointer(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitPointer(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPointer(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PointerContext pointer() {
		PointerContext _localctx = new PointerContext(Context, State);
		EnterRule(_localctx, 62, RULE_pointer);
		try {
			State = 452;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,36,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 443;
				Match(ASTERISK);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 444;
				Match(ASTERISK);
				State = 445;
				type_qualifier_list(0);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 446;
				Match(ASTERISK);
				State = 447;
				pointer();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 448;
				Match(ASTERISK);
				State = 449;
				type_qualifier_list(0);
				State = 450;
				pointer();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_qualifier_listContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Type_qualifierContext type_qualifier() {
			return GetRuleContext<Type_qualifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Type_qualifier_listContext type_qualifier_list() {
			return GetRuleContext<Type_qualifier_listContext>(0);
		}
		public Type_qualifier_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_qualifier_list; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterType_qualifier_list(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitType_qualifier_list(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_qualifier_list(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Type_qualifier_listContext type_qualifier_list() {
		return type_qualifier_list(0);
	}

	private Type_qualifier_listContext type_qualifier_list(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		Type_qualifier_listContext _localctx = new Type_qualifier_listContext(Context, _parentState);
		Type_qualifier_listContext _prevctx = _localctx;
		int _startState = 64;
		EnterRecursionRule(_localctx, 64, RULE_type_qualifier_list, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 455;
			type_qualifier();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 461;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,37,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new Type_qualifier_listContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_type_qualifier_list);
					State = 457;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 458;
					type_qualifier();
					}
					} 
				}
				State = 463;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,37,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class Abstract_declaratorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PointerContext pointer() {
			return GetRuleContext<PointerContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Direct_abstract_declaratorContext direct_abstract_declarator() {
			return GetRuleContext<Direct_abstract_declaratorContext>(0);
		}
		public Abstract_declaratorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_abstract_declarator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterAbstract_declarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitAbstract_declarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAbstract_declarator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Abstract_declaratorContext abstract_declarator() {
		Abstract_declaratorContext _localctx = new Abstract_declaratorContext(Context, State);
		EnterRule(_localctx, 66, RULE_abstract_declarator);
		try {
			State = 469;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,38,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 464;
				pointer();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 465;
				direct_abstract_declarator(0);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 466;
				pointer();
				State = 467;
				direct_abstract_declarator(0);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Direct_abstract_declaratorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CGrammarParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Abstract_declaratorContext abstract_declarator() {
			return GetRuleContext<Abstract_declaratorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CGrammarParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACKET() { return GetToken(CGrammarParser.LBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACKET() { return GetToken(CGrammarParser.RBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Constant_expressionContext constant_expression() {
			return GetRuleContext<Constant_expressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Parameter_type_listContext parameter_type_list() {
			return GetRuleContext<Parameter_type_listContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Direct_abstract_declaratorContext direct_abstract_declarator() {
			return GetRuleContext<Direct_abstract_declaratorContext>(0);
		}
		public Direct_abstract_declaratorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_direct_abstract_declarator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterDirect_abstract_declarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitDirect_abstract_declarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDirect_abstract_declarator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Direct_abstract_declaratorContext direct_abstract_declarator() {
		return direct_abstract_declarator(0);
	}

	private Direct_abstract_declaratorContext direct_abstract_declarator(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		Direct_abstract_declaratorContext _localctx = new Direct_abstract_declaratorContext(Context, _parentState);
		Direct_abstract_declaratorContext _prevctx = _localctx;
		int _startState = 68;
		EnterRecursionRule(_localctx, 68, RULE_direct_abstract_declarator, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 488;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,39,Context) ) {
			case 1:
				{
				State = 472;
				Match(LPAREN);
				State = 473;
				abstract_declarator();
				State = 474;
				Match(RPAREN);
				}
				break;
			case 2:
				{
				State = 476;
				Match(LBRACKET);
				State = 477;
				Match(RBRACKET);
				}
				break;
			case 3:
				{
				State = 478;
				Match(LBRACKET);
				State = 479;
				constant_expression();
				State = 480;
				Match(RBRACKET);
				}
				break;
			case 4:
				{
				State = 482;
				Match(LPAREN);
				State = 483;
				Match(RPAREN);
				}
				break;
			case 5:
				{
				State = 484;
				Match(LPAREN);
				State = 485;
				parameter_type_list();
				State = 486;
				Match(RPAREN);
				}
				break;
			}
			Context.Stop = TokenStream.LT(-1);
			State = 508;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,41,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 506;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,40,Context) ) {
					case 1:
						{
						_localctx = new Direct_abstract_declaratorContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_direct_abstract_declarator);
						State = 490;
						if (!(Precpred(Context, 6))) throw new FailedPredicateException(this, "Precpred(Context, 6)");
						State = 491;
						Match(LBRACKET);
						State = 492;
						Match(RBRACKET);
						}
						break;
					case 2:
						{
						_localctx = new Direct_abstract_declaratorContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_direct_abstract_declarator);
						State = 493;
						if (!(Precpred(Context, 5))) throw new FailedPredicateException(this, "Precpred(Context, 5)");
						State = 494;
						Match(LBRACKET);
						State = 495;
						constant_expression();
						State = 496;
						Match(RBRACKET);
						}
						break;
					case 3:
						{
						_localctx = new Direct_abstract_declaratorContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_direct_abstract_declarator);
						State = 498;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 499;
						Match(LPAREN);
						State = 500;
						Match(RPAREN);
						}
						break;
					case 4:
						{
						_localctx = new Direct_abstract_declaratorContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_direct_abstract_declarator);
						State = 501;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 502;
						Match(LPAREN);
						State = 503;
						parameter_type_list();
						State = 504;
						Match(RPAREN);
						}
						break;
					}
					} 
				}
				State = 510;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,41,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class Function_definitionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Declaration_specifiersContext declaration_specifiers() {
			return GetRuleContext<Declaration_specifiersContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclaratorContext declarator() {
			return GetRuleContext<DeclaratorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Compound_statementContext compound_statement() {
			return GetRuleContext<Compound_statementContext>(0);
		}
		public Function_definitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_definition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterFunction_definition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitFunction_definition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction_definition(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Function_definitionContext function_definition() {
		Function_definitionContext _localctx = new Function_definitionContext(Context, State);
		EnterRule(_localctx, 70, RULE_function_definition);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 511;
			declaration_specifiers();

									enterFunctionDeclarator=true;
									declaratorsNestingLevel=0;
								  
			State = 513;
			declarator();

									declaratorsNestingLevel=0;
									enterFunctionDeclarator=false;
									
									Symbol newSymbol = 
									new Symbol(functioname, Symbol.SymbolType.Function, null);

									CScopeSystem.GetInstance().AddSymbol(CScope.Namespace.Ordinary,
									functioname,newSymbol);
									CScopeSystem.GetInstance().EnterScope(ScopeType.Function,functioname);
								  
			State = 515;
			compound_statement();

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Declaration_specifiersContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Storage_class_specifierContext[] storage_class_specifier() {
			return GetRuleContexts<Storage_class_specifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public Storage_class_specifierContext storage_class_specifier(int i) {
			return GetRuleContext<Storage_class_specifierContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Type_specifierContext[] type_specifier() {
			return GetRuleContexts<Type_specifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public Type_specifierContext type_specifier(int i) {
			return GetRuleContext<Type_specifierContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Type_qualifierContext[] type_qualifier() {
			return GetRuleContexts<Type_qualifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public Type_qualifierContext type_qualifier(int i) {
			return GetRuleContext<Type_qualifierContext>(i);
		}
		public Declaration_specifiersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declaration_specifiers; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterDeclaration_specifiers(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitDeclaration_specifiers(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclaration_specifiers(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Declaration_specifiersContext declaration_specifiers() {
		Declaration_specifiersContext _localctx = new Declaration_specifiersContext(Context, State);
		EnterRule(_localctx, 72, RULE_declaration_specifiers);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 521;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				State = 521;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case AUTO:
				case EXTERN:
				case REGISTER:
				case STATIC:
				case TYPEDEF:
					{
					State = 518;
					storage_class_specifier();
					}
					break;
				case TYPE_NAME:
				case CHAR:
				case DOUBLE:
				case ENUM:
				case FLOAT:
				case INT:
				case LONG:
				case SHORT:
				case SIGNED:
				case STRUCT:
				case UNION:
				case UNSIGNED:
				case VOID:
					{
					State = 519;
					type_specifier();
					}
					break;
				case CONST:
				case VOLATILE:
					{
					State = 520;
					type_qualifier();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 523;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & 8436610150L) != 0) );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Storage_class_specifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPEDEF() { return GetToken(CGrammarParser.TYPEDEF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXTERN() { return GetToken(CGrammarParser.EXTERN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STATIC() { return GetToken(CGrammarParser.STATIC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AUTO() { return GetToken(CGrammarParser.AUTO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REGISTER() { return GetToken(CGrammarParser.REGISTER, 0); }
		public Storage_class_specifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_storage_class_specifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterStorage_class_specifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitStorage_class_specifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStorage_class_specifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Storage_class_specifierContext storage_class_specifier() {
		Storage_class_specifierContext _localctx = new Storage_class_specifierContext(Context, State);
		EnterRule(_localctx, 74, RULE_storage_class_specifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 525;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 303046660L) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_specifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VOID() { return GetToken(CGrammarParser.VOID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHAR() { return GetToken(CGrammarParser.CHAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHORT() { return GetToken(CGrammarParser.SHORT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INT() { return GetToken(CGrammarParser.INT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LONG() { return GetToken(CGrammarParser.LONG, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FLOAT() { return GetToken(CGrammarParser.FLOAT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOUBLE() { return GetToken(CGrammarParser.DOUBLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SIGNED() { return GetToken(CGrammarParser.SIGNED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNSIGNED() { return GetToken(CGrammarParser.UNSIGNED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Struct_or_union_specifierContext struct_or_union_specifier() {
			return GetRuleContext<Struct_or_union_specifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Enum_specifierContext enum_specifier() {
			return GetRuleContext<Enum_specifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPE_NAME() { return GetToken(CGrammarParser.TYPE_NAME, 0); }
		public Type_specifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_specifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterType_specifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitType_specifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_specifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Type_specifierContext type_specifier() {
		Type_specifierContext _localctx = new Type_specifierContext(Context, State);
		EnterRule(_localctx, 76, RULE_type_specifier);
		try {
			State = 539;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case VOID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 527;
				Match(VOID);
				}
				break;
			case CHAR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 528;
				Match(CHAR);
				}
				break;
			case SHORT:
				EnterOuterAlt(_localctx, 3);
				{
				State = 529;
				Match(SHORT);
				}
				break;
			case INT:
				EnterOuterAlt(_localctx, 4);
				{
				State = 530;
				Match(INT);
				}
				break;
			case LONG:
				EnterOuterAlt(_localctx, 5);
				{
				State = 531;
				Match(LONG);
				}
				break;
			case FLOAT:
				EnterOuterAlt(_localctx, 6);
				{
				State = 532;
				Match(FLOAT);
				}
				break;
			case DOUBLE:
				EnterOuterAlt(_localctx, 7);
				{
				State = 533;
				Match(DOUBLE);
				}
				break;
			case SIGNED:
				EnterOuterAlt(_localctx, 8);
				{
				State = 534;
				Match(SIGNED);
				}
				break;
			case UNSIGNED:
				EnterOuterAlt(_localctx, 9);
				{
				State = 535;
				Match(UNSIGNED);
				}
				break;
			case STRUCT:
			case UNION:
				EnterOuterAlt(_localctx, 10);
				{
				State = 536;
				struct_or_union_specifier();
				}
				break;
			case ENUM:
				EnterOuterAlt(_localctx, 11);
				{
				State = 537;
				enum_specifier();
				}
				break;
			case TYPE_NAME:
				EnterOuterAlt(_localctx, 12);
				{
				State = 538;
				Match(TYPE_NAME);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Struct_or_union_specifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Struct_or_unionContext struct_or_union() {
			return GetRuleContext<Struct_or_unionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACE() { return GetToken(CGrammarParser.LBRACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACE() { return GetToken(CGrammarParser.RBRACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(CGrammarParser.IDENTIFIER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Struct_declarationContext[] struct_declaration() {
			return GetRuleContexts<Struct_declarationContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public Struct_declarationContext struct_declaration(int i) {
			return GetRuleContext<Struct_declarationContext>(i);
		}
		public Struct_or_union_specifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_struct_or_union_specifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterStruct_or_union_specifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitStruct_or_union_specifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStruct_or_union_specifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Struct_or_union_specifierContext struct_or_union_specifier() {
		Struct_or_union_specifierContext _localctx = new Struct_or_union_specifierContext(Context, State);
		EnterRule(_localctx, 78, RULE_struct_or_union_specifier);
		int _la;
		try {
			State = 556;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,47,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 541;
				struct_or_union();
				State = 543;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==IDENTIFIER) {
					{
					State = 542;
					Match(IDENTIFIER);
					}
				}

				State = 545;
				Match(LBRACE);
				State = 547;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 546;
					struct_declaration();
					}
					}
					State = 549;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & 8133563490L) != 0) );
				State = 551;
				Match(RBRACE);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 553;
				struct_or_union();
				State = 554;
				Match(IDENTIFIER);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Struct_or_unionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STRUCT() { return GetToken(CGrammarParser.STRUCT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNION() { return GetToken(CGrammarParser.UNION, 0); }
		public Struct_or_unionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_struct_or_union; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterStruct_or_union(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitStruct_or_union(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStruct_or_union(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Struct_or_unionContext struct_or_union() {
		Struct_or_unionContext _localctx = new Struct_or_unionContext(Context, State);
		EnterRule(_localctx, 80, RULE_struct_or_union);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 558;
			_la = TokenStream.LA(1);
			if ( !(_la==STRUCT || _la==UNION) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Struct_declarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Specifier_qualifier_listContext specifier_qualifier_list() {
			return GetRuleContext<Specifier_qualifier_listContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Struct_declarator_listContext struct_declarator_list() {
			return GetRuleContext<Struct_declarator_listContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(CGrammarParser.SEMICOLON, 0); }
		public Struct_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_struct_declaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterStruct_declaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitStruct_declaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStruct_declaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Struct_declarationContext struct_declaration() {
		Struct_declarationContext _localctx = new Struct_declarationContext(Context, State);
		EnterRule(_localctx, 82, RULE_struct_declaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 560;
			specifier_qualifier_list();
			State = 561;
			struct_declarator_list();
			State = 562;
			Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Specifier_qualifier_listContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Type_specifierContext[] type_specifier() {
			return GetRuleContexts<Type_specifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public Type_specifierContext type_specifier(int i) {
			return GetRuleContext<Type_specifierContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Type_qualifierContext[] type_qualifier() {
			return GetRuleContexts<Type_qualifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public Type_qualifierContext type_qualifier(int i) {
			return GetRuleContext<Type_qualifierContext>(i);
		}
		public Specifier_qualifier_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_specifier_qualifier_list; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterSpecifier_qualifier_list(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitSpecifier_qualifier_list(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSpecifier_qualifier_list(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Specifier_qualifier_listContext specifier_qualifier_list() {
		Specifier_qualifier_listContext _localctx = new Specifier_qualifier_listContext(Context, State);
		EnterRule(_localctx, 84, RULE_specifier_qualifier_list);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 566;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				State = 566;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case TYPE_NAME:
				case CHAR:
				case DOUBLE:
				case ENUM:
				case FLOAT:
				case INT:
				case LONG:
				case SHORT:
				case SIGNED:
				case STRUCT:
				case UNION:
				case UNSIGNED:
				case VOID:
					{
					State = 564;
					type_specifier();
					}
					break;
				case CONST:
				case VOLATILE:
					{
					State = 565;
					type_qualifier();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 568;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & 8133563490L) != 0) );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Struct_declarator_listContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Struct_declaratorContext[] struct_declarator() {
			return GetRuleContexts<Struct_declaratorContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public Struct_declaratorContext struct_declarator(int i) {
			return GetRuleContext<Struct_declaratorContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CGrammarParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CGrammarParser.COMMA, i);
		}
		public Struct_declarator_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_struct_declarator_list; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterStruct_declarator_list(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitStruct_declarator_list(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStruct_declarator_list(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Struct_declarator_listContext struct_declarator_list() {
		Struct_declarator_listContext _localctx = new Struct_declarator_listContext(Context, State);
		EnterRule(_localctx, 86, RULE_struct_declarator_list);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 570;
			struct_declarator();
			State = 575;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 571;
				Match(COMMA);
				State = 572;
				struct_declarator();
				}
				}
				State = 577;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Struct_declaratorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeclaratorContext declarator() {
			return GetRuleContext<DeclaratorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(CGrammarParser.COLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Constant_expressionContext constant_expression() {
			return GetRuleContext<Constant_expressionContext>(0);
		}
		public Struct_declaratorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_struct_declarator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterStruct_declarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitStruct_declarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStruct_declarator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Struct_declaratorContext struct_declarator() {
		Struct_declaratorContext _localctx = new Struct_declaratorContext(Context, State);
		EnterRule(_localctx, 88, RULE_struct_declarator);
		try {
			State = 585;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,51,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 578;
				declarator();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 579;
				Match(COLON);
				State = 580;
				constant_expression();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 581;
				declarator();
				State = 582;
				Match(COLON);
				State = 583;
				constant_expression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Enum_specifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENUM() { return GetToken(CGrammarParser.ENUM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACE() { return GetToken(CGrammarParser.LBRACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Enumerator_listContext enumerator_list() {
			return GetRuleContext<Enumerator_listContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACE() { return GetToken(CGrammarParser.RBRACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(CGrammarParser.IDENTIFIER, 0); }
		public Enum_specifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enum_specifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterEnum_specifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitEnum_specifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEnum_specifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Enum_specifierContext enum_specifier() {
		Enum_specifierContext _localctx = new Enum_specifierContext(Context, State);
		EnterRule(_localctx, 90, RULE_enum_specifier);
		try {
			State = 600;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,52,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 587;
				Match(ENUM);
				State = 588;
				Match(LBRACE);
				State = 589;
				enumerator_list();
				State = 590;
				Match(RBRACE);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 592;
				Match(ENUM);
				State = 593;
				Match(IDENTIFIER);
				State = 594;
				Match(LBRACE);
				State = 595;
				enumerator_list();
				State = 596;
				Match(RBRACE);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 598;
				Match(ENUM);
				State = 599;
				Match(IDENTIFIER);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Enumerator_listContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public EnumeratorContext[] enumerator() {
			return GetRuleContexts<EnumeratorContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public EnumeratorContext enumerator(int i) {
			return GetRuleContext<EnumeratorContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CGrammarParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CGrammarParser.COMMA, i);
		}
		public Enumerator_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enumerator_list; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterEnumerator_list(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitEnumerator_list(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEnumerator_list(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Enumerator_listContext enumerator_list() {
		Enumerator_listContext _localctx = new Enumerator_listContext(Context, State);
		EnterRule(_localctx, 92, RULE_enumerator_list);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 602;
			enumerator();
			State = 607;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 603;
				Match(COMMA);
				State = 604;
				enumerator();
				}
				}
				State = 609;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnumeratorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(CGrammarParser.IDENTIFIER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGN() { return GetToken(CGrammarParser.ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Constant_expressionContext constant_expression() {
			return GetRuleContext<Constant_expressionContext>(0);
		}
		public EnumeratorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enumerator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterEnumerator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitEnumerator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEnumerator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EnumeratorContext enumerator() {
		EnumeratorContext _localctx = new EnumeratorContext(Context, State);
		EnterRule(_localctx, 94, RULE_enumerator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 610;
			Match(IDENTIFIER);
			State = 613;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ASSIGN) {
				{
				State = 611;
				Match(ASSIGN);
				State = 612;
				constant_expression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_qualifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONST() { return GetToken(CGrammarParser.CONST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VOLATILE() { return GetToken(CGrammarParser.VOLATILE, 0); }
		public Type_qualifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_qualifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterType_qualifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitType_qualifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_qualifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Type_qualifierContext type_qualifier() {
		Type_qualifierContext _localctx = new Type_qualifierContext(Context, State);
		EnterRule(_localctx, 96, RULE_type_qualifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 615;
			_la = TokenStream.LA(1);
			if ( !(_la==CONST || _la==VOLATILE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Parameter_type_listContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Parameter_declarationContext[] parameter_declaration() {
			return GetRuleContexts<Parameter_declarationContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public Parameter_declarationContext parameter_declaration(int i) {
			return GetRuleContext<Parameter_declarationContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CGrammarParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CGrammarParser.COMMA, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELLIPSIS() { return GetToken(CGrammarParser.ELLIPSIS, 0); }
		public Parameter_type_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameter_type_list; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterParameter_type_list(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitParameter_type_list(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameter_type_list(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Parameter_type_listContext parameter_type_list() {
		Parameter_type_listContext _localctx = new Parameter_type_listContext(Context, State);
		EnterRule(_localctx, 98, RULE_parameter_type_list);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 617;
			parameter_declaration();
			State = 622;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,55,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 618;
					Match(COMMA);
					State = 619;
					parameter_declaration();
					}
					} 
				}
				State = 624;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,55,Context);
			}
			State = 627;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 625;
				Match(COMMA);
				State = 626;
				Match(ELLIPSIS);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Parameter_declarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Declaration_specifiersContext declaration_specifiers() {
			return GetRuleContext<Declaration_specifiersContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclaratorContext declarator() {
			return GetRuleContext<DeclaratorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Abstract_declaratorContext abstract_declarator() {
			return GetRuleContext<Abstract_declaratorContext>(0);
		}
		public Parameter_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameter_declaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterParameter_declaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitParameter_declaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameter_declaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Parameter_declarationContext parameter_declaration() {
		Parameter_declarationContext _localctx = new Parameter_declarationContext(Context, State);
		EnterRule(_localctx, 100, RULE_parameter_declaration);
		int _la;
		try {
			State = 636;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,58,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 629;
				declaration_specifiers();
				State = 630;
				declarator();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 632;
				declaration_specifiers();
				State = 634;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 62)) & ~0x3f) == 0 && ((1L << (_la - 62)) & 1029L) != 0)) {
					{
					State = 633;
					abstract_declarator();
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Compound_statementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACE() { return GetToken(CGrammarParser.LBRACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACE() { return GetToken(CGrammarParser.RBRACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationContext[] declaration() {
			return GetRuleContexts<DeclarationContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationContext declaration(int i) {
			return GetRuleContext<DeclarationContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public Compound_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compound_statement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterCompound_statement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitCompound_statement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompound_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Compound_statementContext compound_statement() {
		Compound_statementContext _localctx = new Compound_statementContext(Context, State);
		EnterRule(_localctx, 102, RULE_compound_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 638;
			Match(LBRACE);
			State = 642;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & 8436610150L) != 0)) {
				{
				{
				State = 639;
				declaration();
				}
				}
				State = 644;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 648;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & 4828281021749494680L) != 0) || ((((_la - 67)) & ~0x3f) == 0 && ((1L << (_la - 67)) & 57407L) != 0)) {
				{
				{
				State = 645;
				statement();
				}
				}
				State = 650;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 651;
			Match(RBRACE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
	 
		public StatementContext() { }
		public virtual void CopyFrom(StatementContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Statement_SelectionStatementContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public Selection_statementContext selection_statement() {
			return GetRuleContext<Selection_statementContext>(0);
		}
		public Statement_SelectionStatementContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterStatement_SelectionStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitStatement_SelectionStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatement_SelectionStatement(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Statement_LabeledStatementContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public Labeled_statementContext labeled_statement() {
			return GetRuleContext<Labeled_statementContext>(0);
		}
		public Statement_LabeledStatementContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterStatement_LabeledStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitStatement_LabeledStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatement_LabeledStatement(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Statement_JumpStatementContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public Jump_statementContext jump_statement() {
			return GetRuleContext<Jump_statementContext>(0);
		}
		public Statement_JumpStatementContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterStatement_JumpStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitStatement_JumpStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatement_JumpStatement(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Statement_IterationStatementContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public Iteration_statementContext iteration_statement() {
			return GetRuleContext<Iteration_statementContext>(0);
		}
		public Statement_IterationStatementContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterStatement_IterationStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitStatement_IterationStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatement_IterationStatement(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Statement_CompoundStatementContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public Compound_statementContext compound_statement() {
			return GetRuleContext<Compound_statementContext>(0);
		}
		public Statement_CompoundStatementContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterStatement_CompoundStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitStatement_CompoundStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatement_CompoundStatement(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Statement_ExpressionStatementContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public Expression_statementContext expression_statement() {
			return GetRuleContext<Expression_statementContext>(0);
		}
		public Statement_ExpressionStatementContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterStatement_ExpressionStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitStatement_ExpressionStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatement_ExpressionStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(Context, State);
		EnterRule(_localctx, 104, RULE_statement);
		try {
			State = 659;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,61,Context) ) {
			case 1:
				_localctx = new Statement_LabeledStatementContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 653;
				labeled_statement();
				}
				break;
			case 2:
				_localctx = new Statement_CompoundStatementContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 654;
				compound_statement();
				}
				break;
			case 3:
				_localctx = new Statement_ExpressionStatementContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 655;
				expression_statement();
				}
				break;
			case 4:
				_localctx = new Statement_SelectionStatementContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 656;
				selection_statement();
				}
				break;
			case 5:
				_localctx = new Statement_IterationStatementContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 657;
				iteration_statement();
				}
				break;
			case 6:
				_localctx = new Statement_JumpStatementContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 658;
				jump_statement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Labeled_statementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(CGrammarParser.IDENTIFIER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(CGrammarParser.COLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement() {
			return GetRuleContext<StatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CASE() { return GetToken(CGrammarParser.CASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Constant_expressionContext constant_expression() {
			return GetRuleContext<Constant_expressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(CGrammarParser.DEFAULT, 0); }
		public Labeled_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_labeled_statement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterLabeled_statement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitLabeled_statement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLabeled_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Labeled_statementContext labeled_statement() {
		Labeled_statementContext _localctx = new Labeled_statementContext(Context, State);
		EnterRule(_localctx, 106, RULE_labeled_statement);
		try {
			State = 672;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case IDENTIFIER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 661;
				Match(IDENTIFIER);
				State = 662;
				Match(COLON);
				State = 663;
				statement();
				}
				break;
			case CASE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 664;
				Match(CASE);
				State = 665;
				constant_expression();
				State = 666;
				Match(COLON);
				State = 667;
				statement();
				}
				break;
			case DEFAULT:
				EnterOuterAlt(_localctx, 3);
				{
				State = 669;
				Match(DEFAULT);
				State = 670;
				Match(COLON);
				State = 671;
				statement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Expression_statementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(CGrammarParser.SEMICOLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Expression_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression_statement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterExpression_statement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitExpression_statement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Expression_statementContext expression_statement() {
		Expression_statementContext _localctx = new Expression_statementContext(Context, State);
		EnterRule(_localctx, 108, RULE_expression_statement);
		try {
			State = 678;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SEMICOLON:
				EnterOuterAlt(_localctx, 1);
				{
				State = 674;
				Match(SEMICOLON);
				}
				break;
			case SIZEOF:
			case INC_OP:
			case DEC_OP:
			case LPAREN:
			case AMBERSAND:
			case NOT:
			case TILDE:
			case HYPHEN:
			case PLUS:
			case ASTERISK:
			case IDENTIFIER:
			case CONSTANT:
			case STRING_LITERAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 675;
				expression(0);
				State = 676;
				Match(SEMICOLON);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Selection_statementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF() { return GetToken(CGrammarParser.IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CGrammarParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CGrammarParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELSE() { return GetToken(CGrammarParser.ELSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SWITCH() { return GetToken(CGrammarParser.SWITCH, 0); }
		public Selection_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selection_statement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterSelection_statement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitSelection_statement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelection_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Selection_statementContext selection_statement() {
		Selection_statementContext _localctx = new Selection_statementContext(Context, State);
		EnterRule(_localctx, 110, RULE_selection_statement);
		try {
			State = 700;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,64,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 680;
				Match(IF);
				State = 681;
				Match(LPAREN);
				State = 682;
				expression(0);
				State = 683;
				Match(RPAREN);
				State = 684;
				statement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 686;
				Match(IF);
				State = 687;
				Match(LPAREN);
				State = 688;
				expression(0);
				State = 689;
				Match(RPAREN);
				State = 690;
				statement();
				State = 691;
				Match(ELSE);
				State = 692;
				statement();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 694;
				Match(SWITCH);
				State = 695;
				Match(LPAREN);
				State = 696;
				expression(0);
				State = 697;
				Match(RPAREN);
				State = 698;
				statement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Iteration_statementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHILE() { return GetToken(CGrammarParser.WHILE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CGrammarParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CGrammarParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement() {
			return GetRuleContext<StatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DO() { return GetToken(CGrammarParser.DO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(CGrammarParser.SEMICOLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(CGrammarParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Expression_statementContext[] expression_statement() {
			return GetRuleContexts<Expression_statementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public Expression_statementContext expression_statement(int i) {
			return GetRuleContext<Expression_statementContext>(i);
		}
		public Iteration_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_iteration_statement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterIteration_statement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitIteration_statement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIteration_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Iteration_statementContext iteration_statement() {
		Iteration_statementContext _localctx = new Iteration_statementContext(Context, State);
		EnterRule(_localctx, 112, RULE_iteration_statement);
		try {
			State = 731;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,65,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 702;
				Match(WHILE);
				State = 703;
				Match(LPAREN);
				State = 704;
				expression(0);
				State = 705;
				Match(RPAREN);
				State = 706;
				statement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 708;
				Match(DO);
				State = 709;
				statement();
				State = 710;
				Match(WHILE);
				State = 711;
				Match(LPAREN);
				State = 712;
				expression(0);
				State = 713;
				Match(RPAREN);
				State = 714;
				Match(SEMICOLON);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 716;
				Match(FOR);
				State = 717;
				Match(LPAREN);
				State = 718;
				expression_statement();
				State = 719;
				expression_statement();
				State = 720;
				Match(RPAREN);
				State = 721;
				statement();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 723;
				Match(FOR);
				State = 724;
				Match(LPAREN);
				State = 725;
				expression_statement();
				State = 726;
				expression_statement();
				State = 727;
				expression(0);
				State = 728;
				Match(RPAREN);
				State = 729;
				statement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Jump_statementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GOTO() { return GetToken(CGrammarParser.GOTO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(CGrammarParser.IDENTIFIER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(CGrammarParser.SEMICOLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONTINUE() { return GetToken(CGrammarParser.CONTINUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BREAK() { return GetToken(CGrammarParser.BREAK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETURN() { return GetToken(CGrammarParser.RETURN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Jump_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jump_statement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.EnterJump_statement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICGrammarParserListener typedListener = listener as ICGrammarParserListener;
			if (typedListener != null) typedListener.ExitJump_statement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICGrammarParserVisitor<TResult> typedVisitor = visitor as ICGrammarParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitJump_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Jump_statementContext jump_statement() {
		Jump_statementContext _localctx = new Jump_statementContext(Context, State);
		EnterRule(_localctx, 114, RULE_jump_statement);
		try {
			State = 746;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,66,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 733;
				Match(GOTO);
				State = 734;
				Match(IDENTIFIER);
				State = 735;
				Match(SEMICOLON);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 736;
				Match(CONTINUE);
				State = 737;
				Match(SEMICOLON);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 738;
				Match(BREAK);
				State = 739;
				Match(SEMICOLON);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 740;
				Match(RETURN);
				State = 741;
				Match(SEMICOLON);
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 742;
				Match(RETURN);
				State = 743;
				expression(0);
				State = 744;
				Match(SEMICOLON);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 1: return postfix_expression_sempred((Postfix_expressionContext)_localctx, predIndex);
		case 6: return multiplicative_expression_sempred((Multiplicative_expressionContext)_localctx, predIndex);
		case 7: return additive_expression_sempred((Additive_expressionContext)_localctx, predIndex);
		case 8: return shift_expression_sempred((Shift_expressionContext)_localctx, predIndex);
		case 9: return relational_expression_sempred((Relational_expressionContext)_localctx, predIndex);
		case 10: return equality_expression_sempred((Equality_expressionContext)_localctx, predIndex);
		case 11: return and_expression_sempred((And_expressionContext)_localctx, predIndex);
		case 12: return exclusive_or_expression_sempred((Exclusive_or_expressionContext)_localctx, predIndex);
		case 13: return inclusive_or_expression_sempred((Inclusive_or_expressionContext)_localctx, predIndex);
		case 14: return logical_and_expression_sempred((Logical_and_expressionContext)_localctx, predIndex);
		case 15: return logical_or_expression_sempred((Logical_or_expressionContext)_localctx, predIndex);
		case 19: return expression_sempred((ExpressionContext)_localctx, predIndex);
		case 29: return direct_declarator_sempred((Direct_declaratorContext)_localctx, predIndex);
		case 32: return type_qualifier_list_sempred((Type_qualifier_listContext)_localctx, predIndex);
		case 34: return direct_abstract_declarator_sempred((Direct_abstract_declaratorContext)_localctx, predIndex);
		}
		return true;
	}
	private bool postfix_expression_sempred(Postfix_expressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(Context, 7);
		case 1: return Precpred(Context, 6);
		case 2: return Precpred(Context, 5);
		case 3: return Precpred(Context, 4);
		case 4: return Precpred(Context, 3);
		case 5: return Precpred(Context, 2);
		case 6: return Precpred(Context, 1);
		}
		return true;
	}
	private bool multiplicative_expression_sempred(Multiplicative_expressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 7: return Precpred(Context, 3);
		case 8: return Precpred(Context, 2);
		case 9: return Precpred(Context, 1);
		}
		return true;
	}
	private bool additive_expression_sempred(Additive_expressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 10: return Precpred(Context, 2);
		case 11: return Precpred(Context, 1);
		}
		return true;
	}
	private bool shift_expression_sempred(Shift_expressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 12: return Precpred(Context, 2);
		case 13: return Precpred(Context, 1);
		}
		return true;
	}
	private bool relational_expression_sempred(Relational_expressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 14: return Precpred(Context, 4);
		case 15: return Precpred(Context, 3);
		case 16: return Precpred(Context, 2);
		case 17: return Precpred(Context, 1);
		}
		return true;
	}
	private bool equality_expression_sempred(Equality_expressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 18: return Precpred(Context, 2);
		case 19: return Precpred(Context, 1);
		}
		return true;
	}
	private bool and_expression_sempred(And_expressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 20: return Precpred(Context, 1);
		}
		return true;
	}
	private bool exclusive_or_expression_sempred(Exclusive_or_expressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 21: return Precpred(Context, 1);
		}
		return true;
	}
	private bool inclusive_or_expression_sempred(Inclusive_or_expressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 22: return Precpred(Context, 1);
		}
		return true;
	}
	private bool logical_and_expression_sempred(Logical_and_expressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 23: return Precpred(Context, 1);
		}
		return true;
	}
	private bool logical_or_expression_sempred(Logical_or_expressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 24: return Precpred(Context, 1);
		}
		return true;
	}
	private bool expression_sempred(ExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 25: return Precpred(Context, 1);
		}
		return true;
	}
	private bool direct_declarator_sempred(Direct_declaratorContext _localctx, int predIndex) {
		switch (predIndex) {
		case 26: return Precpred(Context, 4);
		case 27: return Precpred(Context, 3);
		case 28: return Precpred(Context, 2);
		case 29: return Precpred(Context, 1);
		}
		return true;
	}
	private bool type_qualifier_list_sempred(Type_qualifier_listContext _localctx, int predIndex) {
		switch (predIndex) {
		case 30: return Precpred(Context, 1);
		}
		return true;
	}
	private bool direct_abstract_declarator_sempred(Direct_abstract_declaratorContext _localctx, int predIndex) {
		switch (predIndex) {
		case 31: return Precpred(Context, 6);
		case 32: return Precpred(Context, 5);
		case 33: return Precpred(Context, 2);
		case 34: return Precpred(Context, 1);
		}
		return true;
	}

	private static int[] _serializedATN = {
		4,1,85,749,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,7,
		7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,14,
		2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,21,
		2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,28,
		2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,7,35,
		2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,7,42,
		2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,
		2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,
		2,57,7,57,1,0,1,0,1,0,1,0,1,0,1,0,1,0,3,0,124,8,0,1,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,5,1,152,8,1,10,1,12,1,155,9,1,1,2,1,2,1,2,5,2,160,8,2,10,
		2,12,2,163,9,2,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,
		1,3,3,3,180,8,3,1,4,1,4,1,5,1,5,1,5,1,5,1,5,1,5,3,5,190,8,5,1,6,1,6,1,
		6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,5,6,204,8,6,10,6,12,6,207,9,6,1,
		7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,5,7,218,8,7,10,7,12,7,221,9,7,1,8,1,
		8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,5,8,232,8,8,10,8,12,8,235,9,8,1,9,1,9,1,
		9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,5,9,252,8,9,10,9,12,
		9,255,9,9,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,5,10,266,8,10,10,
		10,12,10,269,9,10,1,11,1,11,1,11,1,11,1,11,1,11,5,11,277,8,11,10,11,12,
		11,280,9,11,1,12,1,12,1,12,1,12,1,12,1,12,5,12,288,8,12,10,12,12,12,291,
		9,12,1,13,1,13,1,13,1,13,1,13,1,13,5,13,299,8,13,10,13,12,13,302,9,13,
		1,14,1,14,1,14,1,14,1,14,1,14,5,14,310,8,14,10,14,12,14,313,9,14,1,15,
		1,15,1,15,1,15,1,15,1,15,5,15,321,8,15,10,15,12,15,324,9,15,1,16,1,16,
		1,16,1,16,1,16,1,16,1,16,3,16,333,8,16,1,17,1,17,1,17,1,17,1,17,3,17,340,
		8,17,1,18,1,18,1,19,1,19,1,19,1,19,1,19,1,19,5,19,350,8,19,10,19,12,19,
		353,9,19,1,20,1,20,1,21,4,21,358,8,21,11,21,12,21,359,1,21,1,21,1,22,1,
		22,3,22,366,8,22,1,23,1,23,3,23,370,8,23,1,23,1,23,1,24,1,24,1,24,5,24,
		377,8,24,10,24,12,24,380,9,24,1,25,1,25,1,25,3,25,385,8,25,1,26,1,26,1,
		26,1,26,1,26,3,26,392,8,26,1,27,1,27,1,27,5,27,397,8,27,10,27,12,27,400,
		9,27,1,28,1,28,1,28,1,28,3,28,406,8,28,1,29,1,29,1,29,1,29,1,29,1,29,1,
		29,3,29,415,8,29,1,29,1,29,1,29,1,29,1,29,1,29,1,29,1,29,1,29,1,29,1,29,
		1,29,1,29,1,29,1,29,1,29,5,29,433,8,29,10,29,12,29,436,9,29,1,30,1,30,
		1,30,1,30,3,30,442,8,30,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,3,
		31,453,8,31,1,32,1,32,1,32,1,32,1,32,5,32,460,8,32,10,32,12,32,463,9,32,
		1,33,1,33,1,33,1,33,1,33,3,33,470,8,33,1,34,1,34,1,34,1,34,1,34,1,34,1,
		34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,3,34,489,8,34,1,34,
		1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,
		1,34,5,34,507,8,34,10,34,12,34,510,9,34,1,35,1,35,1,35,1,35,1,35,1,35,
		1,35,1,36,1,36,1,36,4,36,522,8,36,11,36,12,36,523,1,37,1,37,1,38,1,38,
		1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,3,38,540,8,38,1,39,1,
		39,3,39,544,8,39,1,39,1,39,4,39,548,8,39,11,39,12,39,549,1,39,1,39,1,39,
		1,39,1,39,3,39,557,8,39,1,40,1,40,1,41,1,41,1,41,1,41,1,42,1,42,4,42,567,
		8,42,11,42,12,42,568,1,43,1,43,1,43,5,43,574,8,43,10,43,12,43,577,9,43,
		1,44,1,44,1,44,1,44,1,44,1,44,1,44,3,44,586,8,44,1,45,1,45,1,45,1,45,1,
		45,1,45,1,45,1,45,1,45,1,45,1,45,1,45,1,45,3,45,601,8,45,1,46,1,46,1,46,
		5,46,606,8,46,10,46,12,46,609,9,46,1,47,1,47,1,47,3,47,614,8,47,1,48,1,
		48,1,49,1,49,1,49,5,49,621,8,49,10,49,12,49,624,9,49,1,49,1,49,3,49,628,
		8,49,1,50,1,50,1,50,1,50,1,50,3,50,635,8,50,3,50,637,8,50,1,51,1,51,5,
		51,641,8,51,10,51,12,51,644,9,51,1,51,5,51,647,8,51,10,51,12,51,650,9,
		51,1,51,1,51,1,52,1,52,1,52,1,52,1,52,1,52,3,52,660,8,52,1,53,1,53,1,53,
		1,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,3,53,673,8,53,1,54,1,54,1,54,1,
		54,3,54,679,8,54,1,55,1,55,1,55,1,55,1,55,1,55,1,55,1,55,1,55,1,55,1,55,
		1,55,1,55,1,55,1,55,1,55,1,55,1,55,1,55,1,55,3,55,701,8,55,1,56,1,56,1,
		56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,
		56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,3,56,732,
		8,56,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,
		3,57,747,8,57,1,57,0,15,2,12,14,16,18,20,22,24,26,28,30,38,58,64,68,58,
		0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,
		50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,
		98,100,102,104,106,108,110,112,114,0,5,1,0,67,72,2,0,35,44,61,61,5,0,2,
		2,13,13,20,20,25,25,28,28,2,0,26,26,29,29,2,0,6,6,32,32,805,0,123,1,0,
		0,0,2,125,1,0,0,0,4,156,1,0,0,0,6,179,1,0,0,0,8,181,1,0,0,0,10,189,1,0,
		0,0,12,191,1,0,0,0,14,208,1,0,0,0,16,222,1,0,0,0,18,236,1,0,0,0,20,256,
		1,0,0,0,22,270,1,0,0,0,24,281,1,0,0,0,26,292,1,0,0,0,28,303,1,0,0,0,30,
		314,1,0,0,0,32,332,1,0,0,0,34,339,1,0,0,0,36,341,1,0,0,0,38,343,1,0,0,
		0,40,354,1,0,0,0,42,357,1,0,0,0,44,365,1,0,0,0,46,367,1,0,0,0,48,373,1,
		0,0,0,50,381,1,0,0,0,52,391,1,0,0,0,54,393,1,0,0,0,56,405,1,0,0,0,58,414,
		1,0,0,0,60,441,1,0,0,0,62,452,1,0,0,0,64,454,1,0,0,0,66,469,1,0,0,0,68,
		488,1,0,0,0,70,511,1,0,0,0,72,521,1,0,0,0,74,525,1,0,0,0,76,539,1,0,0,
		0,78,556,1,0,0,0,80,558,1,0,0,0,82,560,1,0,0,0,84,566,1,0,0,0,86,570,1,
		0,0,0,88,585,1,0,0,0,90,600,1,0,0,0,92,602,1,0,0,0,94,610,1,0,0,0,96,615,
		1,0,0,0,98,617,1,0,0,0,100,636,1,0,0,0,102,638,1,0,0,0,104,659,1,0,0,0,
		106,672,1,0,0,0,108,678,1,0,0,0,110,700,1,0,0,0,112,731,1,0,0,0,114,746,
		1,0,0,0,116,124,5,80,0,0,117,124,5,81,0,0,118,124,5,82,0,0,119,120,5,62,
		0,0,120,121,3,38,19,0,121,122,5,63,0,0,122,124,1,0,0,0,123,116,1,0,0,0,
		123,117,1,0,0,0,123,118,1,0,0,0,123,119,1,0,0,0,124,1,1,0,0,0,125,126,
		6,1,-1,0,126,127,3,0,0,0,127,153,1,0,0,0,128,129,10,7,0,0,129,130,5,64,
		0,0,130,131,3,38,19,0,131,132,5,65,0,0,132,152,1,0,0,0,133,134,10,6,0,
		0,134,135,5,62,0,0,135,152,5,63,0,0,136,137,10,5,0,0,137,138,5,62,0,0,
		138,139,3,4,2,0,139,140,5,63,0,0,140,152,1,0,0,0,141,142,10,4,0,0,142,
		143,5,66,0,0,143,152,5,80,0,0,144,145,10,3,0,0,145,146,5,49,0,0,146,152,
		5,80,0,0,147,148,10,2,0,0,148,152,5,47,0,0,149,150,10,1,0,0,150,152,5,
		48,0,0,151,128,1,0,0,0,151,133,1,0,0,0,151,136,1,0,0,0,151,141,1,0,0,0,
		151,144,1,0,0,0,151,147,1,0,0,0,151,149,1,0,0,0,152,155,1,0,0,0,153,151,
		1,0,0,0,153,154,1,0,0,0,154,3,1,0,0,0,155,153,1,0,0,0,156,161,3,34,17,
		0,157,158,5,59,0,0,158,160,3,34,17,0,159,157,1,0,0,0,160,163,1,0,0,0,161,
		159,1,0,0,0,161,162,1,0,0,0,162,5,1,0,0,0,163,161,1,0,0,0,164,180,3,2,
		1,0,165,166,5,47,0,0,166,180,3,6,3,0,167,168,5,48,0,0,168,180,3,6,3,0,
		169,170,3,8,4,0,170,171,3,10,5,0,171,180,1,0,0,0,172,173,5,24,0,0,173,
		180,3,6,3,0,174,175,5,24,0,0,175,176,5,62,0,0,176,177,3,60,30,0,177,178,
		5,63,0,0,178,180,1,0,0,0,179,164,1,0,0,0,179,165,1,0,0,0,179,167,1,0,0,
		0,179,169,1,0,0,0,179,172,1,0,0,0,179,174,1,0,0,0,180,7,1,0,0,0,181,182,
		7,0,0,0,182,9,1,0,0,0,183,190,3,6,3,0,184,185,5,62,0,0,185,186,3,60,30,
		0,186,187,5,63,0,0,187,188,3,10,5,0,188,190,1,0,0,0,189,183,1,0,0,0,189,
		184,1,0,0,0,190,11,1,0,0,0,191,192,6,6,-1,0,192,193,3,10,5,0,193,205,1,
		0,0,0,194,195,10,3,0,0,195,196,5,72,0,0,196,204,3,10,5,0,197,198,10,2,
		0,0,198,199,5,73,0,0,199,204,3,10,5,0,200,201,10,1,0,0,201,202,5,74,0,
		0,202,204,3,10,5,0,203,194,1,0,0,0,203,197,1,0,0,0,203,200,1,0,0,0,204,
		207,1,0,0,0,205,203,1,0,0,0,205,206,1,0,0,0,206,13,1,0,0,0,207,205,1,0,
		0,0,208,209,6,7,-1,0,209,210,3,12,6,0,210,219,1,0,0,0,211,212,10,2,0,0,
		212,213,5,71,0,0,213,218,3,12,6,0,214,215,10,1,0,0,215,216,5,70,0,0,216,
		218,3,12,6,0,217,211,1,0,0,0,217,214,1,0,0,0,218,221,1,0,0,0,219,217,1,
		0,0,0,219,220,1,0,0,0,220,15,1,0,0,0,221,219,1,0,0,0,222,223,6,8,-1,0,
		223,224,3,14,7,0,224,233,1,0,0,0,225,226,10,2,0,0,226,227,5,46,0,0,227,
		232,3,14,7,0,228,229,10,1,0,0,229,230,5,45,0,0,230,232,3,14,7,0,231,225,
		1,0,0,0,231,228,1,0,0,0,232,235,1,0,0,0,233,231,1,0,0,0,233,234,1,0,0,
		0,234,17,1,0,0,0,235,233,1,0,0,0,236,237,6,9,-1,0,237,238,3,16,8,0,238,
		253,1,0,0,0,239,240,10,4,0,0,240,241,5,75,0,0,241,252,3,16,8,0,242,243,
		10,3,0,0,243,244,5,76,0,0,244,252,3,16,8,0,245,246,10,2,0,0,246,247,5,
		52,0,0,247,252,3,16,8,0,248,249,10,1,0,0,249,250,5,53,0,0,250,252,3,16,
		8,0,251,239,1,0,0,0,251,242,1,0,0,0,251,245,1,0,0,0,251,248,1,0,0,0,252,
		255,1,0,0,0,253,251,1,0,0,0,253,254,1,0,0,0,254,19,1,0,0,0,255,253,1,0,
		0,0,256,257,6,10,-1,0,257,258,3,18,9,0,258,267,1,0,0,0,259,260,10,2,0,
		0,260,261,5,54,0,0,261,266,3,18,9,0,262,263,10,1,0,0,263,264,5,55,0,0,
		264,266,3,18,9,0,265,259,1,0,0,0,265,262,1,0,0,0,266,269,1,0,0,0,267,265,
		1,0,0,0,267,268,1,0,0,0,268,21,1,0,0,0,269,267,1,0,0,0,270,271,6,11,-1,
		0,271,272,3,20,10,0,272,278,1,0,0,0,273,274,10,1,0,0,274,275,5,67,0,0,
		275,277,3,20,10,0,276,273,1,0,0,0,277,280,1,0,0,0,278,276,1,0,0,0,278,
		279,1,0,0,0,279,23,1,0,0,0,280,278,1,0,0,0,281,282,6,12,-1,0,282,283,3,
		22,11,0,283,289,1,0,0,0,284,285,10,1,0,0,285,286,5,77,0,0,286,288,3,22,
		11,0,287,284,1,0,0,0,288,291,1,0,0,0,289,287,1,0,0,0,289,290,1,0,0,0,290,
		25,1,0,0,0,291,289,1,0,0,0,292,293,6,13,-1,0,293,294,3,24,12,0,294,300,
		1,0,0,0,295,296,10,1,0,0,296,297,5,78,0,0,297,299,3,24,12,0,298,295,1,
		0,0,0,299,302,1,0,0,0,300,298,1,0,0,0,300,301,1,0,0,0,301,27,1,0,0,0,302,
		300,1,0,0,0,303,304,6,14,-1,0,304,305,3,26,13,0,305,311,1,0,0,0,306,307,
		10,1,0,0,307,308,5,50,0,0,308,310,3,26,13,0,309,306,1,0,0,0,310,313,1,
		0,0,0,311,309,1,0,0,0,311,312,1,0,0,0,312,29,1,0,0,0,313,311,1,0,0,0,314,
		315,6,15,-1,0,315,316,3,28,14,0,316,322,1,0,0,0,317,318,10,1,0,0,318,319,
		5,51,0,0,319,321,3,28,14,0,320,317,1,0,0,0,321,324,1,0,0,0,322,320,1,0,
		0,0,322,323,1,0,0,0,323,31,1,0,0,0,324,322,1,0,0,0,325,333,3,30,15,0,326,
		327,3,30,15,0,327,328,5,79,0,0,328,329,3,38,19,0,329,330,5,60,0,0,330,
		331,3,32,16,0,331,333,1,0,0,0,332,325,1,0,0,0,332,326,1,0,0,0,333,33,1,
		0,0,0,334,340,3,32,16,0,335,336,3,6,3,0,336,337,3,36,18,0,337,338,3,34,
		17,0,338,340,1,0,0,0,339,334,1,0,0,0,339,335,1,0,0,0,340,35,1,0,0,0,341,
		342,7,1,0,0,342,37,1,0,0,0,343,344,6,19,-1,0,344,345,3,34,17,0,345,351,
		1,0,0,0,346,347,10,1,0,0,347,348,5,59,0,0,348,350,3,34,17,0,349,346,1,
		0,0,0,350,353,1,0,0,0,351,349,1,0,0,0,351,352,1,0,0,0,352,39,1,0,0,0,353,
		351,1,0,0,0,354,355,3,32,16,0,355,41,1,0,0,0,356,358,3,44,22,0,357,356,
		1,0,0,0,358,359,1,0,0,0,359,357,1,0,0,0,359,360,1,0,0,0,360,361,1,0,0,
		0,361,362,5,0,0,1,362,43,1,0,0,0,363,366,3,70,35,0,364,366,3,46,23,0,365,
		363,1,0,0,0,365,364,1,0,0,0,366,45,1,0,0,0,367,369,3,72,36,0,368,370,3,
		48,24,0,369,368,1,0,0,0,369,370,1,0,0,0,370,371,1,0,0,0,371,372,5,56,0,
		0,372,47,1,0,0,0,373,378,3,50,25,0,374,375,5,59,0,0,375,377,3,50,25,0,
		376,374,1,0,0,0,377,380,1,0,0,0,378,376,1,0,0,0,378,379,1,0,0,0,379,49,
		1,0,0,0,380,378,1,0,0,0,381,384,3,56,28,0,382,383,5,61,0,0,383,385,3,52,
		26,0,384,382,1,0,0,0,384,385,1,0,0,0,385,51,1,0,0,0,386,392,3,34,17,0,
		387,388,5,57,0,0,388,389,3,54,27,0,389,390,5,58,0,0,390,392,1,0,0,0,391,
		386,1,0,0,0,391,387,1,0,0,0,392,53,1,0,0,0,393,398,3,52,26,0,394,395,5,
		59,0,0,395,397,3,52,26,0,396,394,1,0,0,0,397,400,1,0,0,0,398,396,1,0,0,
		0,398,399,1,0,0,0,399,55,1,0,0,0,400,398,1,0,0,0,401,402,3,62,31,0,402,
		403,3,58,29,0,403,406,1,0,0,0,404,406,3,58,29,0,405,401,1,0,0,0,405,404,
		1,0,0,0,406,57,1,0,0,0,407,408,6,29,-1,0,408,409,5,80,0,0,409,415,6,29,
		-1,0,410,411,5,62,0,0,411,412,3,56,28,0,412,413,5,63,0,0,413,415,1,0,0,
		0,414,407,1,0,0,0,414,410,1,0,0,0,415,434,1,0,0,0,416,417,10,4,0,0,417,
		418,5,64,0,0,418,419,3,40,20,0,419,420,5,65,0,0,420,433,1,0,0,0,421,422,
		10,3,0,0,422,423,5,64,0,0,423,433,5,65,0,0,424,425,10,2,0,0,425,426,5,
		62,0,0,426,427,3,98,49,0,427,428,5,63,0,0,428,433,1,0,0,0,429,430,10,1,
		0,0,430,431,5,62,0,0,431,433,5,63,0,0,432,416,1,0,0,0,432,421,1,0,0,0,
		432,424,1,0,0,0,432,429,1,0,0,0,433,436,1,0,0,0,434,432,1,0,0,0,434,435,
		1,0,0,0,435,59,1,0,0,0,436,434,1,0,0,0,437,442,3,84,42,0,438,439,3,84,
		42,0,439,440,3,66,33,0,440,442,1,0,0,0,441,437,1,0,0,0,441,438,1,0,0,0,
		442,61,1,0,0,0,443,453,5,72,0,0,444,445,5,72,0,0,445,453,3,64,32,0,446,
		447,5,72,0,0,447,453,3,62,31,0,448,449,5,72,0,0,449,450,3,64,32,0,450,
		451,3,62,31,0,451,453,1,0,0,0,452,443,1,0,0,0,452,444,1,0,0,0,452,446,
		1,0,0,0,452,448,1,0,0,0,453,63,1,0,0,0,454,455,6,32,-1,0,455,456,3,96,
		48,0,456,461,1,0,0,0,457,458,10,1,0,0,458,460,3,96,48,0,459,457,1,0,0,
		0,460,463,1,0,0,0,461,459,1,0,0,0,461,462,1,0,0,0,462,65,1,0,0,0,463,461,
		1,0,0,0,464,470,3,62,31,0,465,470,3,68,34,0,466,467,3,62,31,0,467,468,
		3,68,34,0,468,470,1,0,0,0,469,464,1,0,0,0,469,465,1,0,0,0,469,466,1,0,
		0,0,470,67,1,0,0,0,471,472,6,34,-1,0,472,473,5,62,0,0,473,474,3,66,33,
		0,474,475,5,63,0,0,475,489,1,0,0,0,476,477,5,64,0,0,477,489,5,65,0,0,478,
		479,5,64,0,0,479,480,3,40,20,0,480,481,5,65,0,0,481,489,1,0,0,0,482,483,
		5,62,0,0,483,489,5,63,0,0,484,485,5,62,0,0,485,486,3,98,49,0,486,487,5,
		63,0,0,487,489,1,0,0,0,488,471,1,0,0,0,488,476,1,0,0,0,488,478,1,0,0,0,
		488,482,1,0,0,0,488,484,1,0,0,0,489,508,1,0,0,0,490,491,10,6,0,0,491,492,
		5,64,0,0,492,507,5,65,0,0,493,494,10,5,0,0,494,495,5,64,0,0,495,496,3,
		40,20,0,496,497,5,65,0,0,497,507,1,0,0,0,498,499,10,2,0,0,499,500,5,62,
		0,0,500,507,5,63,0,0,501,502,10,1,0,0,502,503,5,62,0,0,503,504,3,98,49,
		0,504,505,5,63,0,0,505,507,1,0,0,0,506,490,1,0,0,0,506,493,1,0,0,0,506,
		498,1,0,0,0,506,501,1,0,0,0,507,510,1,0,0,0,508,506,1,0,0,0,508,509,1,
		0,0,0,509,69,1,0,0,0,510,508,1,0,0,0,511,512,3,72,36,0,512,513,6,35,-1,
		0,513,514,3,56,28,0,514,515,6,35,-1,0,515,516,3,102,51,0,516,517,6,35,
		-1,0,517,71,1,0,0,0,518,522,3,74,37,0,519,522,3,76,38,0,520,522,3,96,48,
		0,521,518,1,0,0,0,521,519,1,0,0,0,521,520,1,0,0,0,522,523,1,0,0,0,523,
		521,1,0,0,0,523,524,1,0,0,0,524,73,1,0,0,0,525,526,7,2,0,0,526,75,1,0,
		0,0,527,540,5,31,0,0,528,540,5,5,0,0,529,540,5,22,0,0,530,540,5,18,0,0,
		531,540,5,19,0,0,532,540,5,14,0,0,533,540,5,10,0,0,534,540,5,23,0,0,535,
		540,5,30,0,0,536,540,3,78,39,0,537,540,3,90,45,0,538,540,5,1,0,0,539,527,
		1,0,0,0,539,528,1,0,0,0,539,529,1,0,0,0,539,530,1,0,0,0,539,531,1,0,0,
		0,539,532,1,0,0,0,539,533,1,0,0,0,539,534,1,0,0,0,539,535,1,0,0,0,539,
		536,1,0,0,0,539,537,1,0,0,0,539,538,1,0,0,0,540,77,1,0,0,0,541,543,3,80,
		40,0,542,544,5,80,0,0,543,542,1,0,0,0,543,544,1,0,0,0,544,545,1,0,0,0,
		545,547,5,57,0,0,546,548,3,82,41,0,547,546,1,0,0,0,548,549,1,0,0,0,549,
		547,1,0,0,0,549,550,1,0,0,0,550,551,1,0,0,0,551,552,5,58,0,0,552,557,1,
		0,0,0,553,554,3,80,40,0,554,555,5,80,0,0,555,557,1,0,0,0,556,541,1,0,0,
		0,556,553,1,0,0,0,557,79,1,0,0,0,558,559,7,3,0,0,559,81,1,0,0,0,560,561,
		3,84,42,0,561,562,3,86,43,0,562,563,5,56,0,0,563,83,1,0,0,0,564,567,3,
		76,38,0,565,567,3,96,48,0,566,564,1,0,0,0,566,565,1,0,0,0,567,568,1,0,
		0,0,568,566,1,0,0,0,568,569,1,0,0,0,569,85,1,0,0,0,570,575,3,88,44,0,571,
		572,5,59,0,0,572,574,3,88,44,0,573,571,1,0,0,0,574,577,1,0,0,0,575,573,
		1,0,0,0,575,576,1,0,0,0,576,87,1,0,0,0,577,575,1,0,0,0,578,586,3,56,28,
		0,579,580,5,60,0,0,580,586,3,40,20,0,581,582,3,56,28,0,582,583,5,60,0,
		0,583,584,3,40,20,0,584,586,1,0,0,0,585,578,1,0,0,0,585,579,1,0,0,0,585,
		581,1,0,0,0,586,89,1,0,0,0,587,588,5,12,0,0,588,589,5,57,0,0,589,590,3,
		92,46,0,590,591,5,58,0,0,591,601,1,0,0,0,592,593,5,12,0,0,593,594,5,80,
		0,0,594,595,5,57,0,0,595,596,3,92,46,0,596,597,5,58,0,0,597,601,1,0,0,
		0,598,599,5,12,0,0,599,601,5,80,0,0,600,587,1,0,0,0,600,592,1,0,0,0,600,
		598,1,0,0,0,601,91,1,0,0,0,602,607,3,94,47,0,603,604,5,59,0,0,604,606,
		3,94,47,0,605,603,1,0,0,0,606,609,1,0,0,0,607,605,1,0,0,0,607,608,1,0,
		0,0,608,93,1,0,0,0,609,607,1,0,0,0,610,613,5,80,0,0,611,612,5,61,0,0,612,
		614,3,40,20,0,613,611,1,0,0,0,613,614,1,0,0,0,614,95,1,0,0,0,615,616,7,
		4,0,0,616,97,1,0,0,0,617,622,3,100,50,0,618,619,5,59,0,0,619,621,3,100,
		50,0,620,618,1,0,0,0,621,624,1,0,0,0,622,620,1,0,0,0,622,623,1,0,0,0,623,
		627,1,0,0,0,624,622,1,0,0,0,625,626,5,59,0,0,626,628,5,34,0,0,627,625,
		1,0,0,0,627,628,1,0,0,0,628,99,1,0,0,0,629,630,3,72,36,0,630,631,3,56,
		28,0,631,637,1,0,0,0,632,634,3,72,36,0,633,635,3,66,33,0,634,633,1,0,0,
		0,634,635,1,0,0,0,635,637,1,0,0,0,636,629,1,0,0,0,636,632,1,0,0,0,637,
		101,1,0,0,0,638,642,5,57,0,0,639,641,3,46,23,0,640,639,1,0,0,0,641,644,
		1,0,0,0,642,640,1,0,0,0,642,643,1,0,0,0,643,648,1,0,0,0,644,642,1,0,0,
		0,645,647,3,104,52,0,646,645,1,0,0,0,647,650,1,0,0,0,648,646,1,0,0,0,648,
		649,1,0,0,0,649,651,1,0,0,0,650,648,1,0,0,0,651,652,5,58,0,0,652,103,1,
		0,0,0,653,660,3,106,53,0,654,660,3,102,51,0,655,660,3,108,54,0,656,660,
		3,110,55,0,657,660,3,112,56,0,658,660,3,114,57,0,659,653,1,0,0,0,659,654,
		1,0,0,0,659,655,1,0,0,0,659,656,1,0,0,0,659,657,1,0,0,0,659,658,1,0,0,
		0,660,105,1,0,0,0,661,662,5,80,0,0,662,663,5,60,0,0,663,673,3,104,52,0,
		664,665,5,4,0,0,665,666,3,40,20,0,666,667,5,60,0,0,667,668,3,104,52,0,
		668,673,1,0,0,0,669,670,5,8,0,0,670,671,5,60,0,0,671,673,3,104,52,0,672,
		661,1,0,0,0,672,664,1,0,0,0,672,669,1,0,0,0,673,107,1,0,0,0,674,679,5,
		56,0,0,675,676,3,38,19,0,676,677,5,56,0,0,677,679,1,0,0,0,678,674,1,0,
		0,0,678,675,1,0,0,0,679,109,1,0,0,0,680,681,5,17,0,0,681,682,5,62,0,0,
		682,683,3,38,19,0,683,684,5,63,0,0,684,685,3,104,52,0,685,701,1,0,0,0,
		686,687,5,17,0,0,687,688,5,62,0,0,688,689,3,38,19,0,689,690,5,63,0,0,690,
		691,3,104,52,0,691,692,5,11,0,0,692,693,3,104,52,0,693,701,1,0,0,0,694,
		695,5,27,0,0,695,696,5,62,0,0,696,697,3,38,19,0,697,698,5,63,0,0,698,699,
		3,104,52,0,699,701,1,0,0,0,700,680,1,0,0,0,700,686,1,0,0,0,700,694,1,0,
		0,0,701,111,1,0,0,0,702,703,5,33,0,0,703,704,5,62,0,0,704,705,3,38,19,
		0,705,706,5,63,0,0,706,707,3,104,52,0,707,732,1,0,0,0,708,709,5,9,0,0,
		709,710,3,104,52,0,710,711,5,33,0,0,711,712,5,62,0,0,712,713,3,38,19,0,
		713,714,5,63,0,0,714,715,5,56,0,0,715,732,1,0,0,0,716,717,5,15,0,0,717,
		718,5,62,0,0,718,719,3,108,54,0,719,720,3,108,54,0,720,721,5,63,0,0,721,
		722,3,104,52,0,722,732,1,0,0,0,723,724,5,15,0,0,724,725,5,62,0,0,725,726,
		3,108,54,0,726,727,3,108,54,0,727,728,3,38,19,0,728,729,5,63,0,0,729,730,
		3,104,52,0,730,732,1,0,0,0,731,702,1,0,0,0,731,708,1,0,0,0,731,716,1,0,
		0,0,731,723,1,0,0,0,732,113,1,0,0,0,733,734,5,16,0,0,734,735,5,80,0,0,
		735,747,5,56,0,0,736,737,5,7,0,0,737,747,5,56,0,0,738,739,5,3,0,0,739,
		747,5,56,0,0,740,741,5,21,0,0,741,747,5,56,0,0,742,743,5,21,0,0,743,744,
		3,38,19,0,744,745,5,56,0,0,745,747,1,0,0,0,746,733,1,0,0,0,746,736,1,0,
		0,0,746,738,1,0,0,0,746,740,1,0,0,0,746,742,1,0,0,0,747,115,1,0,0,0,67,
		123,151,153,161,179,189,203,205,217,219,231,233,251,253,265,267,278,289,
		300,311,322,332,339,351,359,365,369,378,384,391,398,405,414,432,434,441,
		452,461,469,488,506,508,521,523,539,543,549,556,566,568,575,585,600,607,
		613,622,627,634,636,642,648,659,672,678,700,731,746
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
